[toc]

---

<center><font size=7><b>JAVA面向对象</center></font></center>

---



## **1.** 程序设计的思路

面向对象，是软件开发中的一类编程风格、开发范式。

除了`面向对象`，还有`面向过程`、`指令式编程`和`函数式编程`。

在所有的编程范式中，我们**接触最多**的还是<u>面向过程</u>和<u>面向对象</u>两种。

**面向过程（Procedure Oriented Programming）**：强调的是功能行为，以函数为最小单位，考虑怎么做



## 2. 面向对象（Object Oriented Programming）

面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。

**学习面向对象内容的三条主线**

- Java类及类的成员：（重点）属性、方法、构造器；（熟悉）代码块、内部类
- 面向对象的特征：封装、继承、多态、（抽象）
- 其他关键字的使用：this、super、package、import、static、final、interface、abstract等



### 2.1 面向对象思想概述

> - 程序员从面向过程的**执行者**转化成了<u>面向对象</u>的**指挥者**
> - 根据问题需要，选择问题所针对的现实世界中的**实体**。
> - 从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的**类**。
> - 把抽象的实体用计算机语言进行描述，形成计算机世界中**类的定义**。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。
> - 将类实例化成计算机世界中的**对象**。对象是计算机世界中解决问题的最终工具。



### 2.2 四种访问权限修饰符（access modifier）

Java权限修饰符public、protected、 (缺省)、 private置于**类的成员**定义前，用来限定对象对该类成员的访问权限。

| 修饰符    | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 |
| --------- | ------ | -------- | ------------ | ---------- |
| private   | Yes    |          |              |            |
| (缺省)    | Yes    | Yes      |              |            |
| protected | Yes    | Yes      | Yes          |            |
| public    | Yes    | Yes      | Yes          | Yes        |

对于**class的权限修饰**<font color="red">只可以</font>用**public**和**default**(缺省)。
	 public类可以在任意地方被访问。
	 default类只可以被<u>同一个包内部的类</u>访问。



### 2.3 <mark>类(Class)</mark> 和 <mark>对象(Object)</mark> 是面向对象的**<u>核心概念</u>**。

`类`是对一类事物的描述，是抽象的、概念上的定义。将具有相同属性及相同行为的一组对象称为类。广义地讲，具有共同性质的事物的集合就称为类。
	一个类可以包含以下类型变量：
		**`局部变量`**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
		**`成员变量`**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
			**成员变量 <=> 属性 <=> Field**
		**`类变量`**：类变量也声明在类中，方法体之外，但必须声明为 static 类型。
			**(成员)方法 <=> 函数 <=> Method**

`对象`是实际存在的该类事物的**每个**个体，因而也称为**实例<u>(instance)</u>**。
	<u>对象的特征</u>分为**静态特征**和**动态特征**两种：
		-**静态特征**指对象的外观、性质、属性等。
		-**动态特征**指对象具有的功能、行为等。



#### 2.3.1类的基本语法格式

> **`类的声明`**
>
> 1. 定义类（考虑修饰符、类名）
> 2. 编写类的属性（考虑修饰符、属性类型、属性名、初始化值）
> 3. 编写类的方法（考虑修饰符、返回值类型、方法名、形参等）
> 
> ```java
> 
> 修饰符 class 类名{
> 属性声明;
> 方法声明;
> }
> 
> // 访问类的成员对象（包括属性和方法）
> // 在一个类中的访问机制：类中的方法可以直接访问类中的成员变量，无论是否为私有。
> 对象名.对象成员
> 
> ```

> **`类的对象创建`**
>
> 对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：
>
> - **声明**：声明一个对象，包括对象名称和对象类型。
> - **实例化**：使用关键字 `new` 来创建一个对象。
> - **初始化**：使用 new 创建对象时，会调用构造方法初始化对象。
>
> ```java
> // 创建对象语法
> 类名 对象名 = new 类名();
> new Person().shout() //匿名对象:不定义对象的句柄，而直接调用这个对象的方法。
>     
> //方式2：
> new 类名()//也称为匿名对象
> //如果一个对象只需要进行一次方法调用，那么就可以使用匿名对象。
> ```
>



> **`对象使用（调用属性或方法）`**
>
> 如果要访问对象里的某个成员变量或方法，可以通过下面的语法来实现。
>
> ```java
> //访问属性：
> 对象名称 . 属性名
>    
> //访问方法：
> 对象名称 . 方法名()
> ```
>
> 
>
> **`对象比较`**
>
> 有两种方式可用于对象间的比较，即“= =”运算符与equals()方法。
>
> 
>
> **`对象数组`**
>
> 数组的元素可以是基本数据类型，也可以是引用数据类型。当元素是引用类型中的类时，我们称为**对象数组**。
>
> **举例**：String[]就是一个对象数组，上诉的Person，使用Person[]的形式也就成了对象数组



#### 2.3.2类的内部成员

`成员含有`：属性，方法，构造器，代码块，内部类



##### 成员1：属性 （成员变量(field)）

**`属性声明`** ：修饰符 数据类型 属性名 = 初始化值 ;

- `说明` 
  - 1: **修饰符**
    	常用的权限修饰符有：private、缺省、protected、public、static、final
  - 2：**数据类型**
    	基本数据类型(如int、Boolean) 或 任何引用数据类型。
  - 3：**属性名**
    	属于标识符，符合命名规则和规范即可.

变量`分类`：
		在方法体外，类体内声明的变量称为`成员变量`。
		在方法体内部声明的变量称为`局部变量`。



<div>			<!--块级封装-->
<center>	<!--将图片和文字居中-->
<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230409867.png"
   alt="无法显示图片时显示的文字"
   style="zoom:0.6"/>
<br><br>
<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230410130.png"
   alt="无法显示图片时显示的文字"
   style="zoom:0.45"/>
<br>		<!--换行-->
	变量的分类：成员变量与局部变量	<!--标题-->
</center>
</div>



<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230410194.png" alt="image-20240316141452185" style="zoom: 40%;" />





##### 成员2：类的构造器 又称构造方法 / 构造函数（constructor）

`构造器分类`：
	**隐式无参构造器**（系统默认提供）
	**显式定义一个或多个构造器**（无参、有参）

`注意`：
	Java语言中，每个类都**至少有一个**构造器
	<u>默认构造器的**修饰符**</u>与所属类的修饰符一致
	一旦**显式**定义了构造器，则系统**不再**提供默认构造器
	一个类可以创建多个重载的构造器
	**父类的构造器不可被子类继承**





##### 成员3：方法（method）

- `方法`是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为`函数`或`过程`。
- 将功能封装为方法的目的是，可以`实现代码重用，减少冗余，简化代码`
- Java里的方法`不能独立存在`，所有的方法必须定义在类里。

> **`方法定义`**
>
> ```java
> 修饰符 返回值类型 方法名（参数类型 形参1, 参数类型 形参2, ….）[throws 异常列表]｛
> 	方法体程序代码
> 	return 返回值;
> ｝
> ```

（1）**一个完整的方法 = 方法头 + 方法体。**

- 方法头就是`[修饰符] 返回值类型 方法名([形参列表])[throws 异常列表]`，也称为`方法签名`。通常调用方法时只需要关注方法头就可以，从方法头可以看出这个方法的功能和调用格式。
- 方法体就是方法被调用后要执行的代码。对于调用者来说，不了解方法体如何实现的，并不影响方法的使用。

**（2）方法头可能包含5个部分**

- **修饰符**：可选的。方法的修饰符也有很多，例如：public、protected、private、static、abstract、native、final、synchronized等，后面会一一学习。
  - 其中，权限修饰符有public、protected、private。在讲封装性之前，我们先默认使用pulbic修饰方法。
  - 其中，根据是否有static，可以将方法分为静态方法和非静态方法。其中静态方法又称为类方法，非静态方法又称为实例方法。咱们在讲static前先学习实例方法。
- **返回值类型**： 表示方法运行的结果的数据类型，方法执行后将结果返回到调用者。
  - 无返回值，则声明：void
  - 有返回值，则声明出返回值类型（可以是任意类型）。与方法体中“`return 返回值`”搭配使用
- **方法名**：属于标识符，命名时遵循标识符命名规则和规范，“见名知意”
- **形参列表**：表示完成方法体功能时需要外部提供的数据列表。可以包含零个，一个或多个参数。
  - 无论是否有参数，()不能省略
  - 如果有参数，每一个参数都要指定数据类型和参数名，多个参数之间使用逗号分隔，例如：
    - 一个参数： (数据类型 参数名)
    - 二个参数： (数据类型1 参数1, 数据类型2 参数2)
  - 参数的类型可以是基本数据类型、引用数据类型
- **throws 异常列表**（可选）

**（3）方法体**：方法体必须有{}括起来，在{}中编写完成方法功能的代码

**（4）关于方法体中return语句的说明：**

- return语句的作用是结束方法的执行，并将方法的结果返回去
- 如果返回值类型不是void，方法体中必须保证一定有 return 返回值; 语句，并且要求该返回值结果的类型与声明的返回值类型一致或兼容。
- 如果返回值类型为void时，方法体中可以没有return语句，如果要用return语句提前结束方法的执行，那么return后面不能跟返回值，直接写return ; 就可以。
- return语句后面就不能再写其他代码了，否则会报错：Unreachable code

- return在方法中的**作用**：
  - 作用1：结束一个方法
  - 作用2：结束一个方法的同时，可以返回数据给方法的调用者
- 注意点：在return关键字的直接后面不能声明执行语句

补充：方法的分类：按照是否有形参及返回值

<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230410991.png" alt="img" style="zoom:50%;" />



###### 方法的参数传递机制

- 形参（formal parameter）：在定义方法时，方法名后面括号()中声明的变量称为形式参数，简称形参。
- 实参（actual parameter）：在调用方法时，方法名后面括号()中的使用的值/变量/表达式称为实际参数，简称实参。

**`参数传递机制：值传递`**  Java里方法的参数传递方式只有一种：`值传递`。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。

- 形参是**基本数据类型**：将实参基本数据类型变量的“**数据值**”传递给形参
- 形参是**引用数据类型**：将实参引用数据类型变量的“**地址值**”传递给形参





###### 方法的重载(overload)

**`概念`**：在同一个类中，允许存在一个以上的同名方法，只要它们的<u>参数个数或者参数类型不同即可</u>。

**`特点`**：与返回值类型无关，只看参数列表，且<u>参数列表必须不同</u>。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别

- 重载方法`调用` ：JVM通过方法的参数列表，调用匹配的方法。
  - 先找个数、类型最匹配的
  - 再找个数和类型可以兼容的，如果同时多个方法可以兼容将会报错



###### 方法的重写(override/overwrite)

**`定义`**：在子类中可以根据需要对<u>从父类中继承来的方法</u>进行改造，也称为方法的<font color="red">重置</font>、<font color="red">覆盖</font>。在程序执行时，子类的方法将覆盖父类的方法。

- **`要求`**：
  1. 子类重写的方法必须和父类被重写的方法具有<u>相同</u>的<u>方法名称</u>、<u>参数列表</u>
  2. 子类重写的方法的<u>返回值类型</u>**不能**<u>大于</u>父类被重写的方法的返回值类型
  3. 子类重写的方法使用的<u>访问权限</u>**不能**<u>小于</u>父类被重写的方法的访问权限
     - 子类**不能**重写父类中声明为<u>private权限</u>的方法
  4. 子类方法<u>抛出的异常</u>**不能**<u>大于</u>父类被重写方法的异常

**注意**：子类与父类中<u>同名同参数</u>的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。

`@Override`是伪代码,表示重写(当然不写也可以)，不过写上有如下好处:
	1、可以当注释用,方便阅读；
	2、编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写@Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。



###### 重载与重写

`从编译和运行的角度看`：

重载，是指允许存在多个同名方法，而这些方法的参数不同。

编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在**<u>编译期就绑定</u>**了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。

所以，对于**重载**而言，在**<u>方法调用之前</u>**，编译器就已经确定了所要调用的方法，这称为“**早绑定**”或“**静态绑定**”；

而对于**多态**，只有等到**<u>方法调用的那一刻</u>**，解释运行器才会确定所要调用的具体方法，这称为“**晚绑定**”或“**动态绑定**”。



###### 可变个数的形参

JavaSE 5.0 中提供了**Varargs(**variable number of arguments**)**机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。

>**格式：**
>
>```java
>方法名(参数的类型名 ...参数名)
>```

//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量

​	**public static void test(int a ,String[] books);**

//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量

> **public static void test(int a ,<font color="darkred">String…books</font>);**

- **说明：**
  1. 声明格式：方法名(参数的类型名 ...参数名)
  2. 可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个
  3. 可变个数形参的方法与同名的方法之间，彼此构成重载
  4. 可变参数方法的使用与方法参数部分使用数组是一致的
  5. 方法的参数部分有可变形参，需要放在形参声明的最后
  6. 在一个方法的形参位置，最多只能声明一个可变个数形参



###### 递归方法

递归方法：一个方法体内调用它自身。
	方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。
	递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环



###### 理解main方法的语法

​	由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public，又因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数

​	又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。

> **命令行参数用法举例**
>
> ```java
> public class Test {
> public static void main(String[] args) {
>   for (int i = 0; i < args.length; i++) {
>       System.out.println("args[" + i + "] = " + args[i]);
>   }
> }
> }
> ```
>
> 在控制台输入： java Test.java "Tom" "Jerry" "Shkstart"
>
> ![image-20240326011454075](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230410202.png)
>
> 输出：1
>
> ![image-20240326011504339](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230410347.png)
>
> <img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230410981.png" alt="image-20240326011431051" style="zoom: 50%;" />







##### 成员4：代码块

代码块(或 <u>初始化块</u>) 的 `作用`：对Java类或对象进行初始化

代码块(或 <u>初始化块</u>)的`分类`：
			一个类中代码块若有修饰符，则只能被static修饰，称为**静态代码块**(static block)
			没有使用static修饰的，为**非静态代码块**

> static代码块通常用于初始化static的属性
>
> ```java
> class Person {
> 	public static int total;
> 	static {
> 		total = 100;//为total赋初值
> 	}
> 	…… //其它属性或方法声明
> }
> ```



###### 静态代码块

在代码块的前面加static，就是静态代码块。

- 静态代码块的`特点`
  1. 可以有输出语句。
  2. 可以对类的属性、类的声明进行初始化操作。
  3. 不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。
  4. 若有多个静态的代码块，那么按照从上到下的顺序依次执行。
  5. 静态代码块的执行要先于非静态代码块。
  6. 静态代码块随着类的加载而加载，且只执行一次。

`语法格式`

```java
【修饰符】 class 类{
	static{
        静态代码块
    }
}
```

> **静态初始化块举例**
>
> ```java
> class Person {
> 	public static int total;
> 	static {
> 		total = 100;
> 		System.out.println("in static block!");
> 	}
> }
> 
> public class PersonTest {
> 	public static void main(String[] args) {
> 		System.out.println("total = " + Person.total);
> 		System.out.println("total = " + Person.total);
> 	}
> }
> ```
>
> <img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230411641.png" alt="image-20240326015608868" style="zoom: 50%;" />



###### 非静态代码块

没有static修饰的代码块

- 非静态代码块的`特点`：
  1. 可以有输出语句。
  2. 可以对类的属性、类的声明进行初始化操作。
  3. 除了调用非静态的结构外，还可以调用静态的变量或方法。
  4. 若有多个非静态的代码块，那么按照从上到下的顺序依次执行。
  5. 每次创建对象的时候，都会执行一次。且先于构造器执行。

语法格式

```java
【修饰符】 class 类{
    {
        非静态代码块
    }
    【修饰符】 构造器名(){
    	// 实例初始化代码
    }
    【修饰符】 构造器名(参数列表){
        // 实例初始化代码
    }
}
```



<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230411418.png" alt="image-20240326015746686" style="zoom: 33%;" />







#### 2.3.3 抽象类与抽象方法

`抽象类`：随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做**抽象类**。

`抽象方法`：只有方法的声明，没有方法的实现。以分号结束，如：public abstract void talk();

- 用abstract关键字来修饰一个类，这个类叫做抽象类。
- 用abstract来修饰一个方法，该方法叫做抽象方法。

- **`注意`**：
  - **含有抽象方法**的类**必须被声明为抽象类**。
  - 抽象类**不能被实例化**，不能创建对象。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。
  - 抽象类中，也有构造方法，是供子类创建对象时，初始化父类成员变量使用的。子类的构造方法中，有默认的super()或手动的super(实参列表)，需要访问父类构造方法。
  - 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象。未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。
  - 抽象类的子类，必须重写抽象父类中**所有的**抽象方法。
  - 不能用abstract修饰<u>变量</u>、<u>代码块</u>、<u>构造器</u>；
  - 不能用abstract修饰私有方法、静态方法、final的方法、final的类。

抽象类的`语法格式`

```java
[权限修饰符] abstract class 类名{
    //...
}
[权限修饰符] abstract class 类名 extends 父类{
    //...
}
```

抽象方法的`语法格式`  （ 注意：抽象方法没有方法体）

```java
[其他修饰符] abstract 返回值类型 方法名([形参列表]);
```



抽象类`应用`：抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。
	**Java**允许类设计者指定：超类声明一个方法但不提供实现，该方法的实现由子类提供。这样的方法称为抽象方法。有一个或更多抽象方法的类称为抽象类。

> 举例：在航运公司系统中，Vehicle类需要定义两个方法分别计算运输工具的燃料效率和行驶距离。
>
> 问题：卡车(Truck)和驳船(RiverBarge)的燃料效率和行驶距离的计算方法完全不同。Vehicle类不能提供计算方法，但子类可以。
>
> ```java
> //Vehicle是一个抽象类，有两个抽象方法。
> public abstract class Vehicle{
> 	public abstract double calcFuelEfficiency(); //计算燃料效率的抽象方法
> 	public abstract double calcTripDistance(); //计算行驶距离的抽象方法
> }
> public class Truck extends Vehicle{
> 	public double calcFuelEfficiency( ... ... ) {  ... ... //写出计算卡车的燃料效率的具体方法 }
> 	public double calcTripDistance( ... ... ) { ... ... //写出计算卡车行驶距离的具体方法 }
> }
> public class RiverBarge extends Vehicle{
> 	public double calcFuelEfficiency( ... ...) {  ... ... //写出计算驳船的燃料效率的具体方法 }
> 	public double calcTripDistance(  ... ...) {  ... ...//写出计算驳船行驶距离的具体方法}
> }
> public class Test {
> 	public static void main(String args[]) {
> 		Vehicle a = new Truck();
> 		Vehicle a = new RiverBarge();
> 	}
> }
> ```
>
> 注意：抽象类不能实例化 new Vihicle()是非法的
>
> <img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230412737.png" alt="image-20240326115755177" style="zoom:50%;" />



##### 多态的应用：模板方法设计模式(TemplateMethod)

  抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式.

**解决的问题**：当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。

模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：
	数据库访问的封装
	Junit单元测试
	JavaWeb的Servlet中关于doGet/doPost方法调用
	Hibernate中模板程序
	Spring中JDBCTemlate、HibernateTemplate等





#### 2.3.4 接口(interface)

Java的软件系统会有很多模块组成，那么各个模块之间也应该采用这种`面向接口`的`低耦合`，为系统提供更好的可扩展性和可维护性。

`接口(interface)`：是抽象方法和常量值定义的集合。

- **`概述`**：
  - 一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。
  - 另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有is-a关系（继承关系），仅仅是具有相同的行为特征而已。
        例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。
  - 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要...则必须能...”的思想。
    继承是一个"是不是"的`is-a`关系，而接口实现则是 "能不能"的`has-a`关系。
  - 接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守。



> 举例
>
> <img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230412002.png" alt="image-20240326141931035" style="zoom:33%;" />
>
> <img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230412319.png" alt="image-20240326142002161" style="zoom:33%;" />



接口的`定义格式`：
	接口的定义，它与定义类方式相似，但是使用 `interface` 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。



接口的`成员说明`：

**在JDK8.0 之前**，接口中只允许出现：
（1）公共的静态的常量：其中`public static final` 可以省略
（2）公共的抽象的方法：其中`public abstract` 可以省略

> 理解：接口是从多个相似类中抽象出来的规范，不需要提供具体实现

**在JDK8.0 时**，接口中允许声明`默认方法`和`静态方法`：
（3）公共的默认的方法：其中public 可以省略，建议保留，但是default不能省略
（4）公共的静态的方法：其中public 可以省略，建议保留，但是static不能省略

**在JDK9.0 时**，接口又增加了：
（5）私有方法

- 接口中**没有构造器**，没有初始化块，因为接口中没有成员变量需要动态初始化。



**接口的`使用规则`**

**1、类实现接口（implements）**
	接口**不能创建对象**，但是可以被类实现（`implements` ，类似于被继承）。
	类与接口的关系为实现关系，即**类实现接口**，该类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 `implements`关键字。

**2、接口的<u>多实现</u>（implements）**
	之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的**多实现**。并且，一个类能继承一个父类，同时实现多个接口。

**3、接口的多继承(extends)**
	一个接口能继承另一个或者多个接口，接口的继承也使用 `extends` 关键字，子接口继承父接口的方法。

**4、接口与实现类对象构成多态引用**
	实现类实现接口，类似于子类继承父类，因此，接口类型的变量与实现类的对象之间，也可以构成多态引用。通过接口类型的变量调用方法，最终执行的是你new的实现类对象实现的方法体。

**5、使用接口的静态成员**
	接口不能直接创建对象，但是可以通过接口名直接调用接口的静态方法和静态常量。

**6、使用接口的非静态方法**

- 对于接口的静态方法，直接使用“ 接口名 . ”进行调用即可
  - 也只能使用“接口名."进行调用，不能通过实现类的对象进行调用
- 对于接口的抽象方法、默认方法，只能通过实现类对象才可以调用
  - 接口不能直接创建对象，只能创建实现类的对象



接口的`声明格式`

```java
[修饰符] interface 接口名{
    //接口的成员列表：
    // 公共的静态常量
    // 公共的抽象方法
    
    // 公共的默认方法（JDK1.8以上）
    // 公共的静态方法（JDK1.8以上）
    // 私有方法（JDK1.9以上）
}
```



接口使用`语法格式`：先写 **extends**，后写 **implements**  →  class SubClass <font color="red">extends</font> SuperClass **<font color="red">implements</font>** InterfaceA{ }

-  一个类可以实现多个接口，接口也可以继承其它接口。
- 实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。
- 接口的主要用途就是被实现类实现。**（面向接口编程）**
- 与继承关系类似，接口与实现类之间存在多态性
- 接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义 ( JDK7.0及之前 )，而没有变量和方法的实现



**默认方法冲突问题**（JDK8)

**（1）类优先原则**
当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的抽象方法重名，子类就近选择执行父类的成员方法。|

**（2）接口冲突（左右为难）**
选择保留其中一个，通过在“`接口名.super.方法名`"的方法选择保留哪个接口的默认方法。
或者直接重写

```java
//假设A、B接口都含有方法C
public class Girl implements A, B{
    @Override
    public void C() {
        //(1)二选一，保留其中一个父接口的
//        A.super.C();
//        B.super.C();
        //(2)完全重写
        System.out.println("123");
    }
}
```



**常量冲突问题**

- 当子类继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。
- 当子类同时实现多个接口，而多个接口存在相同同名常量。

此时在子类中想要引用父类或父接口的同名的常量或成员变量时，就会有冲突问题。



> 子接口重写默认方法时，default关键字可以保留。
>
> 子类重写默认方法时，default关键字不可以保留。



> <img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230412256.png" alt="image-20240326142554580" style="zoom: 40%;" />

接口应用举例：

> ```java
> interface Runner {
> 	public void start();
> 	public void run();
> 	public void stop();
> }
> interface Swimmer {
>  public double swim();
> }
> interface Student extends Runner{
>  public double study();
> }
> class Creator{
>  public int eat(){…}
> }
> 
> // 一个类可以实现多个无关的接口
> class Man extends Creator implements Runner ,Swimmer{
> 	public void start() {
> 		// 准备工作：弯腰、蹬腿、咬牙、瞪眼
> 		// 开跑
> 	}
> 	public void run() {
> 		// 摆动手臂
> 		// 维持直线方向
> 	}
> 	public void stop() {
> 		// 减速直至停止、喝水。
> 	}
> 	public double swim() {……}
> 	public int eat() {……}
> 	public void walk() {......}
> }
> 
> //实现类SubAdapter必须给出接口SubInterface以及父接口MyInterface中所有方法的实现。否则，SubAdapter仍需声明为abstract的。
> class Woman implements Student {
> 	public void start() {......}
> 	public void run() {......}
> 	public void stop() {......}
> 	public double study(){......}
> }
> 
> // 与继承关系类似，接口与实现类之间存在多态性
> public class Test{
> 	public static void main(String args[]){
>      	Test t = new Test();
> 		Man m = new Man();
> 		t.m1(m);
> 		t.m2(m);
> 		t.m3(m);
> 	}
> 	public String m1(Runner f) { f.run(); }
> 	public void m2(Swimmer s) {s.swim();}
> 	public void m3(Creator a) {a.eat();}
> }
> ```



`Java 8中关于接口的改进`

Java 8中，你可以为接口内添加<u>静态方法</u>和<u>默认方法</u>。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。

**静态方法：**使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像Collection/Collections或者Path/Paths这样成对的接口和类。
		接口中声明的静态方法**只能被接口来调用**，不能使用其实现类进行调用。

**默认方法：**默认方法使用 default 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。
	       比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认方法。

- 若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现：**接口冲突。**
    **解决办法**：实现类必须覆盖接口中同名同参数的方法，来解决冲突。
- 若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。因为此时遵守：**类优先原则。**接口中具有相同名称和参数的默认方法会被忽略。

个人理解：方法声明不写default就会被认为是抽象方法
				如果写了default就要有方法具体实现，被继承时可以重写也可以不重写。但是有default方法的接口，被继承时，不能与其他被继承的接口，有同名同参数的方法，而且子类不重写。



`JDK 9 接口的新特性`

接口可以定义**<u>私有方法</u>**。

实际上这些私有方法是给默认方法使用的。将默认方法中相同的方法提取出来，并且不对外暴露，便形成接口的私有方法。



`新特性举例`

> 知识点1~5为JDK8
> ```java
> public interface CompareA {
> 	//静态方法
> 	public static void method1(){
>         	System.out.println("CompareA：北京");
> 	}
> 	//默认方法
> 	public default void method2(){
>         	System.out.println("CompareA：上海");
> 	}
>     
> 	public default void method3(){
>         	System.out.println("CompareA：广州");
> 	}
>     
> 	public default void method4(){
>         	System.out.println("CompareA：深圳");
> 	}
> }
> public interface CompareB {
> 	
> 	public default void method3(){
>         	System.out.println("CompareA：广州");
> 	}
> }
> 
> public class Subclass implements CompareA, CompareB{
> 	@Override
> 	public  void method2(){
>         	System.out.println("SubClass：上海"); //对方法2进行重写
> 	}
>     
> 	public void method3(){	//此处必须重写，否则出现接口冲突，既看作是对CompareA的重写，又看作是对CompareB的重写。
>         	System.out.println("SubClass：广州");
> 	}
>     
> 	public void method4(){
>         	System.out.println("SubClass：深圳");
> 	}
>     
> 	// 知识点5：如何在子类（或实现类）中调用父类或接口中被重写的方法。
> 	public void method(){
> 		method4(); //调用自己类中的方法
>         
> 		super.method4(); //调用父类中的方法
>         
> 		CompareA.super.method3(); //调用接口CompareA中的默认方法
> 		CompareB.super.method3(); //调用接口CompareB中的默认方法
> 	}
> }
> 
> //接口存在冲突，报错
> public static void main(String[] args){
>     //知识点1：接口中声明的静态方法只能被接口调用，不能使用其实现类来进行调用
>     CompareA.method1();
>     //SubClass.method1();  <--报错
>     
>     //知识点2：接口中声明的默认方法可以被实现类继承，实现类没有重写此方法的情况下，默认调用接口中声明的默认方法。如果有实现类重写此方法，则调用的是自己重写的方法。
>     SubClass s1 = new SubClass();
>     s1.method2();
>     
>     //知识点3：类实现了两个接口，而两个接口中定义了同名同参数的默认方法，则实现类在没有重写此两个接口默认方法下会报错 --------> 接口冲突
>     //要求：此时必须实现类要重写接口中定义的同名同参数的方法。
>     s1.method3();
>     
>     //知识点4：子类（或实现类）继承了父类并实现接口。父类和接口中声明了同名同参数的方法。（其中，接口的方法是默认方法）。默认情况下，子类在没有重写此方法的情况下，调用的是父类中的方法。--------> 类优先原则
>     s1.method4();
>     
>     
> }
> 
> 
> ```
>
> 



#### 2.3.5 接口 和 抽象类 之间的对比

> <div>			<!--块级封装-->
> <center>	<!--将图片和文字居中-->
> <img src="C:\Users\86503\Desktop\Markdown笔记\JAVA笔记\3.JAVA面向对象\image-20240326144943973.png" alt="image-20240326144943973" style="zoom: 40%;" />
> <br>		<!--换行-->
> 接口和抽象类之间的对比	<!--标题-->
> </center>
> </div>





#### 2.3.6 内部类

  当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用**内部类**。

  在Java中，允许一个类的定义位于另一个类的内部，前者称为**内部类**，后者称为**外部类**。

  Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。

  Inner class的名字**不能**与包含它的外部类类名相同；

**`分类`**：成员内部类（static成员内部类和非static成员内部类）
			**局部内部类**（不谈修饰符）、匿名内部类



个人理解：声明 private、protected 和 abstract 等的就是成员内部类，无任何声明就是局部内部类.



###### 成员内部类

- **成员内部类作为<u>类的成员</u>的角色：**
  - 和外部类不同，Inner class还可以声明为**private**或**protected**；
  - 可以调用外部类的结构
  - Inner class 可以声明为**static**的，但此时就不能再使用外层类的非static的成员变量；

- **成员内部类作为<u>类</u>的角色：**
  - 可以在内部定义属性、方法、构造器等结构
  - 可以声明为**abstract**类 ，因此可以被其它的内部类继承
  - 可以声明为**final**的
  - 编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）



- `注意`：
  1. 非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员。
  2. 外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式
  3. 成员内部类可以直接使用外部类的所有成员，包括私有的数据
  4. 当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的



###### 局部内部类

> `声明局部内部类`
>
> ```java
> class 外部类{
> 	方法(){
> 		class 局部内部类{ ... ... }
> 	}
> 	{
> 		class 局部内部类{ ... ... }
> 	}
> }
> ```

- **局部内部类的`特点`**
  - 内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号。
  - 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。
  - 局部内部类可以使用外部类的成员，包括私有的。
  - 局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周期不同所致。
  - 局部内部类和局部变量地位类似，不能使用public,protected,缺省,private
  - 局部内部类不能使用static修饰，因此也不能包含静态成员



###### 匿名内部类

  匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。

>**格式：**
>
>```java
>new 父类构造器（实参列表）| 实现接口(){
>	//匿名内部类的类体部分
>}
>```

- **匿名内部类的`特点`**
  - 匿名内部类必须继承父类或实现接口
  - 匿名内部类只能有一个对象
  - 匿名内部类对象只能使用多态形式引用

> 举例
>
> ```java
> interface A{
> 	public abstract void fun1();
> }
> public class Outer{
> 	public static void main(String[] args) {
> 		new Outer().callInner(new A(){
> 		//接口是不能new但此处比较特殊是子类对象实现接口，只不过没有为对象取名
> 			public void fun1() {
> 				System.out.println(“implement for fun1");
> 			}
> 		});// 两步写成一步了
> 	}
> 	public void callInner(A a) {
> 		a.fun1();
> 	}
> }
> ```
>
> 





#### 2.3.7 枚举类（Enum）

- `概述`
	- 枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。
	  > 枚举类的例子举不胜举：
	  > - **星期**：Monday(星期一)…Sunday(星期天)
	  > - **性别**：Man(男)、Woman(女)
	  > - **月份**：January(1月)…December(12月)
	  > - **季节**：Spring(春节)…Winter(冬天)
	  > - **三原色**：red(红色)、green(绿色)、blue(蓝色)
	  > - **支付方式**：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)
	  > - **就职状态**：Busy(忙碌)、Free(空闲)、Vocation(休假)、Dimission(离职)
	  > - **订单状态**：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Checked（已确认收货）、Return（退货）、Exchange（换货）、Cancel（取消）
	  > - **线程状态**：创建、就绪、运行、阻塞、死亡

	- **若枚举只有一个对象, 则可以作为一种单例模式的实现方式。**



- 枚举类的`实现`：
  - 在JDK5.0 之前，需要程序员自定义枚举类型。
  - 在JDK5.0 之后，Java支持`enum`关键字来快速定义枚举类型。



**`定义枚举类`**

**JDK5.0 之前**

- `私有化`类的构造器，保证不能在类的外部创建其对象
- 在类的内部创建枚举类的实例。声明为：`public static final` ，对外暴露这些常量对象
- 对象如果有`实例变量`，应该声明为`private final`（建议，不是必须），并在构造器中初始化

```java
//举例
class Season{
    private final String SEASONNAME;//季节的名称
    private final String SEASONDESC;//季节的描述
    private Season(String seasonName,String seasonDesc){
        this.SEASONNAME = seasonName;
        this.SEASONDESC = seasonDesc;
    }
    public static final Season SPRING = new Season("春天", "春暖花开");
    public static final Season SUMMER = new Season("夏天", "夏日炎炎");
    public static final Season AUTUMN = new Season("秋天", "秋高气爽");
    public static final Season WINTER = new Season("冬天", "白雪皑皑");

    @Override
    public String toString() {
        return "Season{" +
                "SEASONNAME='" + SEASONNAME + '\'' +
                ", SEASONDESC='" + SEASONDESC + '\'' +
                '}';
    }
}

class SeasonTest{
    public static void main(String[] args) {
        System.out.println(Season.AUTUMN);
    }
}
```



**JDK5.0 之后**

```java
//enum关键字声明枚举
【修饰符】 enum 枚举类名{
    常量对象列表
}

【修饰符】 enum 枚举类名{
    常量对象列表;
    
    对象的实例变量列表;
}
```

```java
//举例
public enum SeasonEnum {
    //必须在开头列出实例化对象，省略public static final
    SPRING("春天","春风又绿江南岸"),
    SUMMER("夏天","映日荷花别样红"),
    AUTUMN("秋天","秋水共长天一色"),
    WINTER("冬天","窗含西岭千秋雪");

    private final String seasonName;
    private final String seasonDesc;
    
    private SeasonEnum(String seasonName, String seasonDesc) {	//私有化构造器
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }
    
    public String getSeasonName() {
        return seasonName;
    }
    public String getSeasonDesc() {
        return seasonDesc;
    }
}

```



**enum方式定义的`要求和特点`**

- 枚举类的常量对象列表必须在枚举类的首行，因为是常量，所以建议大写。
- 列出的实例系统会自动添加 public static final 修饰。
- 如果常量对象列表后面没有其他代码，那么“；”可以省略，否则不可以省略“；”。
- 编译器给枚举类默认提供的是private的无参构造，如果枚举类需要的是无参构造，就不需要声明，写常量对象列表时也不用加参数
- 如果枚举类需要的是有参构造，需要手动定义，有参构造的private可以省略，调用有参构造的方法就是在常量对象名后面加(实参列表)就可以。
- 枚举类默认继承的是java.lang.Enum类，因此不能再继承其他的类型。
- JDK5.0 之后switch，提供支持枚举类型，case后面可以写枚举常量名，无需添加枚举类作为限定。



**enum中`常用方法`**

```csharp
String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！
    
static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法
    
static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。
    
String name():得到当前枚举常量的名称。建议优先使用toString()。
    
int ordinal():返回当前枚举常量的次序号，默认从0开始
```

```java
// 举例
import java.util.Scanner;
 
public class TestEnumMethod {
    public static void main(String[] args) {
        //values()
        Week[] values = Week.values();
        for (int i = 0; i < values.length; i++) {
            //ordinal()、name()
            System.out.println((values[i].ordinal()+1) + "->" + values[i].name());
        }
        System.out.println("------------------------");
 
        Scanner input = new Scanner(System.in);
        System.out.print("请输入星期值：");
        int weekValue = input.nextInt();
        Week week = values[weekValue-1];
        //toString()
        System.out.println(week);
 
        System.out.print("请输入星期名：");
        String weekName = input.next();
        //valueOf()
        week = Week.valueOf(weekName);
        System.out.println(week);
 
        input.close();
    }
}
```



**`实现接口`的枚举类**

- 和普通 Java 类一样，枚举类可以实现一个或多个接口
- 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。
- 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法

语法：

```java
//1、枚举类可以像普通的类一样，实现接口，并且可以多个，但要求必须实现里面所有的抽象方法！
enum A implements 接口1，接口2{
	//抽象方法的实现
}
 
//2、如果枚举类的常量可以继续重写抽象方法!
enum A implements 接口1，接口2{
    常量名1(参数){
        //抽象方法的实现或重写
    },
    常量名2(参数){
        //抽象方法的实现或重写
    },
    //...
}
```

```jaVA
//举例
interface Info{
	void show();
}

//使用enum关键字定义枚举类
enum Season1 implements Info{
	//1. 创建枚举类中的对象,声明在enum枚举类的首位
	SPRING("春天","春暖花开"){
		public void show(){
			System.out.println("春天在哪里？");
		}
	},
	SUMMER("夏天","夏日炎炎"){
		public void show(){
			System.out.println("宁静的夏天");
		}
	},
	AUTUMN("秋天","秋高气爽"){
		public void show(){
			System.out.println("秋天是用来分手的季节");
		}
	},
	WINTER("冬天","白雪皑皑"){
		public void show(){
			System.out.println("2002年的第一场雪");
		}
	};
	
	//2. 声明每个对象拥有的属性:private final修饰
	private final String SEASON_NAME;
	private final String SEASON_DESC;
	
	//3. 私有化类的构造器
	private Season1(String seasonName,String seasonDesc){
		this.SEASON_NAME = seasonName;
		this.SEASON_DESC = seasonDesc;
	}
	
	public String getSEASON_NAME() {
		return SEASON_NAME;
	}

	public String getSEASON_DESC() {
		return SEASON_DESC;
	}

	//统一实现接口
	//public void show(){
    	//System.out.println("2002年的第一场雪");
	//}
    
}
```



>经验之谈：开发中，当需要定义一组常量时，强烈建议使用枚举类。





#### 2.3.8 注解（Annotation）

注解（Annotation）是从`JDK5.0`开始引入，以“`@注解名`”在代码中存在。

Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在 Annotation 的 “name=value” 对中。

注解可以在类编译、运行时进行加载，体现不同的功能。



**`注解与注释`**：注解也可以看做是一种注释，通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。但是，注解，不同于单行注释和多行注释。

- 对于单行注释和多行注释是给程序员看的。
- 而注解是可以被编译器或其他程序读取的。程序还可以根据注解的不同，做出相应的处理。



`注解的重要性`：在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在`JavaEE/Android中注解占据了更重要的角色`，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的`繁冗代码`和`XML配置`等。
		未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，Struts2有一部分也是基于注解的了。`注解是一种趋势`，一定程度上可以说：`框架 = 注解 + 反射 + 设计模式`。



**常见的Annotation作用**

```java
//1：生成文档相关的注解
@author 标明开发该类模块的作者，多个作者之间使用,分割
@version 标明该类模块的版本
@see 参考转向，也就是相关主题
@since 从哪个版本开始增加的
@param 对方法中某参数的说明，如果没有参数就不能写
@return 对方法返回值的说明，如果方法的返回值类型是void就不能写
@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写

//举例：
package com.annotation.javadoc;
/**
 * @author *****
 * @version 1.0
 * @see Math.java
 */
public class JavadocTest {
	/**
	 * 程序的主方法，程序的入口
	 * @param args String[] 命令行参数
	 */
	public static void main(String[] args) {
	}
	
	/**
	 * 求圆面积的方法
	 * @param radius double 半径值
	 * @return double 圆的面积
	 */
	public static double getArea(double radius){
		return Math.PI * radius * radius;
	}
}
```

```java
//2：在编译时进行格式检查(JDK内置的三个基本注解)
@Override: 限定重写父类方法，该注解只能用于方法
@Deprecated: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择
@SuppressWarnings: 抑制编译器警告
    
package com.annotation.javadoc;
 
public class AnnotationTest{
 
	public static void main(String[] args) {
		@SuppressWarnings("unused")
		int a = 10;
	}
	@Deprecated
	public void print(){
		System.out.println("过时的方法");
	}
 
	@Override
	public String toString() {
		return "重写的toString方法()";
	}
}
```

```java
//3：跟踪代码依赖性，实现替代配置文件功能
//Servlet3.0提供了注解(annotation)，使得不再需要在web.xml文件中进行Servlet的部署。
@WebServlet("/login")
public class LoginServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
    
    protected void doGet(HttpServletRequest request, HttpServletResponse response) { }
    
    protected void doPost(HttpServletRequest request, HttpServletResponse response) {
        doGet(request, response);
	}  
}


 <servlet>
    <servlet-name>LoginServlet</servlet-name>
    <servlet-class>com.servlet.LoginServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>LoginServlet</servlet-name>
    <url-pattern>/login</url-pattern>
  </servlet-mapping>
```

```java
//Spring框架中关于“事务”的管理

@Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)
public void buyBook(String username, String isbn) {
	//1.查询书的单价
    int price = bookShopDao.findBookPriceByIsbn(isbn);
    //2. 更新库存
    bookShopDao.updateBookStock(isbn);	
    //3. 更新用户的余额
    bookShopDao.updateUserAccount(username, price);
}


<!-- 配置事务属性 -->
<tx:advice transaction-manager="dataSourceTransactionManager" id="txAdvice">
       <tx:attributes>
       <!-- 配置每个方法使用的事务属性 -->
       <tx:method name="buyBook" propagation="REQUIRES_NEW" 
	 isolation="READ_COMMITTED"  read-only="false"  timeout="3" />
       </tx:attributes>
</tx:advice>
```



**三个最基本的注解**

- **@Override**
	- 用于检测被标记的方法为有效的重写方法，如果不是，则报编译错误！
	- 只能标记在方法上。
	- 它会被编译器程序读取。

- **@Deprecated**
	- 用于表示被标记的数据已经过时，不推荐使用。
	- 可以用于修饰 属性、方法、构造、类、包、局部变量、参数。
	- 它会被编译器程序读取。

- **@SuppressWarnings**
	- 抑制编译警告。当我们不希望看到警告信息的时候，可以使用 SuppressWarnings 注解来抑制警告信息
	- 可以用于修饰类、属性、方法、构造、局部变量、参数
	- 它会被编译器程序读取。
	- 可以指定的警告类型有（了解）
	  - all，抑制所有警告
	  - unchecked，抑制与未检查的作业相关的警告
	  - unused，抑制与未用的程式码及停用的程式码相关的警告
	  - deprecation，抑制与淘汰的相关警告
	  - nls，抑制与非 nls 字串文字相关的警告
	  - null，抑制与空值分析相关的警告
	  - rawtypes，抑制与使用 raw 类型相关的警告
	  - static-access，抑制与静态存取不正确相关的警告
	  - static-method，抑制与可能宣告为 static 的方法相关的警告
	  - super，抑制与置换方法相关但不含 super 呼叫的警告
	  - …



`元注解`：JDK1.5在java.lang.annotation包定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。

（1）**@Target：**用于描述注解的使用范围

- 可以通过枚举类型ElementType的10个常量对象来指定
- TYPE，METHOD，CONSTRUCTOR，PACKAGE…

（2）**@Retention：**用于描述注解的生命周期

- 可以通过枚举类型 RetentionPolicy 的3个常量对象来指定
- SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）
- `唯有RUNTIME阶段才能被反射读取到`。

（3）**@Documented**：表明这个注解应该被 javadoc工具记录。

（4）**@Inherited：**允许子类继承父类中的注解



**自定义注解的使用**

一个完整的注解应该包含三个部分：
（1）声明
（2）使用
（3）读取

```java
【元注解】
【修饰符】 @interface 注解名{
    【成员列表】
}
```

- 自定义注解可以通过四个元注解@Retention,@Target，@Inherited,@Documented，分别说明它的声明周期，使用位置，是否被继承，是否被生成到API文档中。
- Annotation 的成员在 Annotation 定义中以无参数有返回值的抽象方法的形式来声明，我们又称为配置参数。返回值类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组
- 可以使用 default 关键字为抽象方法指定默认返回值
- 如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是“方法名 = 返回值”，如果只有一个抽象方法需要赋值，且方法名为value，可以省略“value=”，所以如果注解只有一个抽象方法成员，建议使用方法名value。





#### 2.3.9 包装类(Wrapper)

Java提供了两个类型系统，`基本数据类型`与`引用数据类型`。

针对八种基本数据类型定义相应的引用类型—包装类（封装类）。有了类的特点，就可以**调用类中的方法**.

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| byte         | Byte      |
| short        | Short     |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |
| boolean      | Boolean   |
| char         | Character |



**内存结构**

```java
public static void main(String[] args){
	int num = 520;
	Integer obj = new Integer(520);
}
```

<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230412212.png" alt="img" style="zoom:80%;" />





**包装类与基本数据类型间的转换**

> **基本数据类型包装成包装类的实例 ---`装箱`**
> 	包装类使得一个<u>基本数据</u>类型的数据变成了<u>类</u>。
> 	有了类的特点，可以<u>调用类中的方法</u>。
>
> ```java
> //通过包装类的<u>构造器</u>实现： 
> int i = 500;  Integer t = new Integer(i);
> 
> //还可以通过<u>字符串参数</u>构造包装类对象：
> Float f = new Float(“4.56”);
> Long l = new Long(“asdf”);  //出错：NumberFormatException
> 
> //使用包装类中的valueOf方法
> Integer obj2 = Integer.valueOf(4);
> ```
>
> 
>
> **获得包装类对象中包装的基本类型变量 ---`拆箱`**
> 	将数字<u>包装类中内容</u>变为<u>基本数据类型</u>。
> 	包装类在实际开发中用的最多的在于字符串变为基本数据类型。
>
> ```java
> //调用包装类的.xxxValue()方法： 
> Boolean obj1 = new Boolean(true);
> boolean b = obj1.booleanValue();
> 
> Integer obj2 = new Integer(4);
> int num1 = obj2.intValue();
> ```
>
> 
>
> **`自动装箱与拆箱`**
>
> JDK1.5之后，支持自动装箱，自动拆箱。但类型必须匹配。
>
> 注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。
>
> ```java
> Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);
> i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;
> //加法运算完成后，再次装箱，把基本数值转成对象。
> ```
>
> 
>
> > **`字符串转换成基本数据类型`**
> >
> > - 通过包装类的构造器实现：
> >   - int i = new Integer(“12”);
> > - 通过包装类的parseXxx(String s)静态方法：
> >   - Float f = Float.parseFloat(“12.1”);
> > - valueOf 将字符串参数转换为对应的Integer包装类，然后可以自动拆箱为int基本类型 
> >   - 
> >
> >
> > **`基本数据类型转换成字符串`**
> >
> > - 调用字符串重载的valueOf()方法：
> >   - String fstr = String.valueOf(2.34f);
> > - 更直接的方式：
> >   - String intStr = 5 + “”
>
> > 包装类用法`举例`
> >
> > ```JAVA
> > //装箱
> > int i = 500;
> > Integer t = new Integer(i);
> > 
> > String s = t.toString(); // s = “500“,t是类，有toString方法
> > String s1 = Integer.toString(314); // s1= “314“ 将数字转换成字符串。
> > String s2=“4.56”;
> > double ds=Double.parseDouble(s2); //将字符串转换成数字
> > 
> > //拆箱
> > int j = t.intValue(); // j = 500，intValue取出包装类中的数据
> > 
> > String str1 = "30" ;
> > String str2 = "30.3" ;
> > int x = Integer.parseInt(str1) ; // 将字符串变为int型
> > float f = Float.parseFloat(str2) ; // 将字符串变为int型
> > ```
> >
> > 

<div>			<!--块级封装-->
<center>	<!--将图片和文字居中-->
<img src="C:\Users\86503\Desktop\Markdown笔记\JAVA笔记\3.JAVA面向对象\image-20240323231454376.png"
   alt="无法显示图片时显示的文字"
   style="zoom:1"/>
<br>		<!--换行-->
基本类型、包装类与String类间的转换	<!--标题-->
</center>
</div>



**包装类其他Api**

```java
//数据类型的最大最小值
Integer.MAX_VALUE和Integer.MIN_VALUE
Long.MAX_VALUE和Long.MIN_VALUE
Double.MAX_VALUE和Double.MIN_VALUE
```

```java
//字符转大小写
Character.toUpperCase('x');
Character.toLowerCase('X');

```

```java
//整数转进制
Integer.toBinaryString(int i) 
Integer.toHexString(int i)
Integer.toOctalString(int i)
```

```java
//比较的方法
Double.compare(double d1, double d2)
Integer.compare(int x, int y) 
```





#### 2.3.10 JavaBean类

JavaBean是一种Java语言写成的可重用组件。

JavaBean是指符合如下标准的Java类：
	1.类是<u>公共</u>(public)的.
	2.有一个<u>无参的公共的构造器</u>.
	3.<u>有属性</u>，且有<u>对应的get、set方法</u>.

用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。





### 2.4 类的内存解析

```java
public class Person{
    String name;
    int age;
    char gender;
    public void eat(){
        ...
    }
    public void sleep(int hour){
        ...
    }
    public void interests(String hobby){
        ...
    }
}
```

​	JDK7以后<u>字符串常量池</u>放在**堆**里

​	**栈**(stack)：方法内定义的变量，存储在栈中。
​	**堆**(heap)：new 出来的结构(例：数组实体、对象的实体)。包括对象中的属性。
​	**方法区**(method area)：存放类的模板。

​	**方法调用**：
​		**方法参数的值传递机制**：Java里方法的参数传递方式只有一种：**值传递**。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。
​				形参是<u>基本数据类型</u>：将实参基本数据类型变量的“**数据值**”传递给形参
​				形参是<u>引用数据类型</u>：将实参引用数据类型变量的“**地址值**”传递给形参

提醒：对象名中存储的是对象地址

```java
public static void main(String[] args){
    Person p1 = new Person();
    p1.name =“杰克”;
    p1.age = 24;

    Person p2 = new Person();
    p2.name="露丝";
    p2.age = 20;
    
    p1.age = 26;
    
    Person p3 = p1; // p3与p1地址相同
    p3.age = 28;
    
    p1.eat();
    p1.sleep(6);
    p1.interests("编程");
}
```

<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230412854.png" alt="image3-1" style="zoom: 50%;" />





### 2.5 关键字

#### 2.5.1 this

**this** 可以调用类的属性、方法和构造器。

- **`作用`**：
  - 它在**方法内部**使用，即这个方法所属对象的引用；
  - 它在**构造器内部**使用，表示该构造器正在初始化的对象。
  - 可以用this来<u>区分</u>属性和局部变量。
    当形参与成员变量**同名**时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量。

使用this访问属性和方法时，如果在本类中未找到，会从父类中查找



#### 2.5.2 super

在Java类中使用super来<u>**调用父类**</u>中的指定操作。

- **`作用`**：
  
   	1. super可用于访问父类中定义的**属性**
   	2. super可用于调用父类中定义的**成员方法**
   	3. super可用于在子类构造器中调用父类的**构造器**
  
- **`注意`**：
  
  - 尤其当子父类出现**同名成员**时，可以用super表明调用的是父类中的成员。
  - super的追溯**不仅限**于直接父类。
  - super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识。
  
  

| this和super的区别 | 区别点     | this                                                   | super                                    |
| :---------------- | ---------- | ------------------------------------------------------ | ---------------------------------------- |
| 1                 | 访问属性   | 访问本类中的属性，如果本类没有此属性则从父类中继续查找 | 直接访问父类中的属性                     |
| 2                 | 调用方法   | 访问本类中的方法，如果本类没有此方法则从父类中继续查找 | 直接访问父类中的方法                     |
| 3                 | 调用构造器 | 调用本类构造器，必须放在构造器的首行                   | 调用父类构造器，必须放在子类构造器的首行 |

- `注意`：
  - 子类中所有的构造器**默认**都会访问父类中**空参数**的构造器
  - 当父类中没有空参数的构造器时，子类的构造器**必须**通过**this(参数列表)**或者**super(参数列表)**语句指定调用本类或者父类中相应的构造器。如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则**编译出错**。
  - 构造参数内 this 与 super 作为构造器的指代时，只能二选一 。
  - this 与 super 作为构造器的指代时，必须放在构造器的首行。

> 举例
> ```Java
> class Person {
> 	protected String name;
> 	protected int age;
> 	public Person(String name, int age, Date d) {
> 		this.name = name;
> 		this.age = age;
> 		this.birthDate = d;
> 	}
> 	public Person(String name, int age) {
> 		this(name, age, null);	//调用本类的构造器(this)
> 	}
> 	public String getInfo() {
> 		return "Name: " + name + "\nage: " + age;
> 	}
> }
> 
> class Student extends Person {
> 	protected String name;
> 	public Student(String name, int age, String s) {
> 		super(name, age);	//调用父类构造器
> 		school = s;
> 	}
> 	public String getInfo() {
> 		return super.getInfo() + "\nschool: " + school;	//调用父类方法
> 	}
> }
> 
> public class StudentTest {
> 	public static void main(String[] args) {
> 		Student st = new Student();
> 		System.out.println(st.getInfo());
> 	}
> }
> ```
>



#### 2.5.3 static

类属性、类方法的`设计思想`：当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产生出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。

  我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份.

关键字static的`使用范围`：在Java类中，可用static修饰<u>属性</u>、<u>方法</u>、<u>代码块</u>、<u>内部类</u>

被static修饰后的成员具备以下`特点`：
	1.随着类的加载而加载
	2.优先于对象存在
	3.修饰的成员，被所有对象所共享
	4.访问权限允许时，可不创建对象，直接被类调用



##### 静态变量（或 类变量、类属性）

使用static修饰的成员变量就是静态变量（或类变量、类属性）

静态变量（或 类变量、类属性）是类对象所拥有的属性，作为该类各个对象之间共享的变量，在内存中只存在一个副本。
				
在设计类时,分析哪些属性不因对象的不同而改变，将这些属性设置为类属性。相应的方法设置为类方法

```java
[修饰符] class 类{
	[其他修饰符] static 数据类型 变量名;
}
```

- 静态变量的`特点`
	- 静态变量的默认值规则和实例变量一样。
	- 静态变量值是所有对象共享。
	- 静态变量在本类中，可以在任意方法、代码块、构造器中直接使用。
	- 如果权限修饰符允许，在其他类中可以通过“`类名.静态变量`”直接访问，也可以通过“`对象.静态变量`”的方式访问（但是更推荐使用类名.静态变量的方式）。
	- 静态变量的get/set方法也静态的，当局部变量与静态变量`重名时`，使用“`类名.静态变量`”进行区分。



##### 静态方法（或 类方法）

用static修饰的成员方法就是静态方法。

如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。

在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。
								因为不需要实例就可以访问static方法，因此static方法内部不能有this和super。
								static修饰的方法不能被重写

```java
[修饰符] class 类{
	[其他修饰符] static 返回值类型 方法名(形参列表){
        方法体
    }
}
```

- 静态方法的`特点`
	- 静态方法在本类的任意方法、代码块、构造器中都可以直接被调用。
	- 只要权限修饰符允许，静态方法在其他类中可以通过“类名.静态方法“的方式调用。也可以通过”对象.静态方法“的方式调用（但是更推荐使用类名.静态方法的方式）。
	- 在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。
	- 静态方法可以被子类继承，但不能被子类重写。
	- 静态方法的调用都只看编译时类型。
	- 因为不需要实例就可以访问static方法，因此static方法内部不能有this，也不能有super。如果有重名问题，使用“类名.”进行区别。





##### 对比实例变量与静态变量（类变量）

静态变量:类中的属性使用static进行修饰。对比静态变量与实例变量
>① 个数
>-静态变量:在内存空间中只有一份，被类的多个对象所共享。
>-实例变量:类的每一个实例(或对象)都保存着一份实例变量。
>② 内存位置
>-静态变量：jdk6及之前:存放在方法区。jdk7及之后:存放在堆空间。
>-实例变量，存放在堆空间的对象实体中。
>③ 加载时机
>静态变量:随着类的加载而加载，由于类只会加载一次，所以静态变量也只有一份。
>实例变量:随着对象的创建而加载。每个对象拥有一份实例变量
>④ 调用者
>静态变量:可以被类直接调用，也可以使用对象调用。
>实例变量，只能使用对象进行调用
>⑤ 消亡时机
>静态变量:随着类的卸载而消亡
>实例变量:随着对象的销亡而消亡



##### 内存解析

jdk6：静态变量（静态域）处于方法区（永久代）（永久代是方法区的一个具体实现）。

jdk7：静态变量（静态域）处于堆（堆的GC频繁，方法区很少GC，导致回收不及时）。

jdk8：静态变量（静态域）仍处于堆。方法区实现换为"元空间"，使用本地内存。

<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230413190.png" alt="image-20240325021147107"  />



##### 单例 (Singleton)设计模式

  `设计模式`是在<u>大量的实践中</u><u>总结</u>和<u>理论化</u>之后<u>优选</u>的**代码结构**、编程风格、以及解决问题的思考方式。
				设计模免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。”套路”

​	所谓类的**单例设计模式**，就是采取一定的方法保证在整个的软件系统中，对某个类**只能存在一个对象实例**，并且该类**只提供一个取得其对象实例的方法**。
​	如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的**构造器**的<u>访问权限设置为private</u>，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，**只能调用该类的某个静态方法以返回类内部创建的对象**，静态方法只能访问类中的静态成员变量，所以，**指向类内部产生的该类对象的变量也必须定义成静态的**。

`单例模式的优点`：由于单例模式只生成一个实例，**减少了系统性能开销**，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。

> **应用场景**
>
> - Windows的Task Manager (任务管理器)就是很典型的单例模式
> - Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。
> - Application 也是单例的典型应用
> - 应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
> - 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。



###### 饿汉式 与 懒汉式 的 区别

> 单例(Singleton)设计模式-饿汉式
> 		定义时就实例化
>
> ```java
> class Singleton {
> 	// 1.私有化构造器
> 	private Singleton() {}
> 	// 2.内部提供一个当前类的实例
> 	// 4.此实例也必须静态化
> 	private static Singleton single = new Singleton();
> 	// 3.提供公共的静态的方法，返回当前类的对象
> 	public static Singleton getInstance() {
> 		return single;
> 	}
> }
> ```
>
> 

> 单例(Singleton)设计模式-懒汉式
> 		需要获取时候才实例化
>
> ```java
> class Singleton {
> 	// 1.私有化构造器
> 	private Singleton() {}
> 	// 2.内部提供一个当前类的实例
> 	// 4.此实例也必须静态化
> 	private static Singleton single;
> 	// 3.提供公共的静态的方法，返回当前类的对象
> 	public static Singleton getInstance() {
> 		if(single == null) {
> 			single = new Singleton();
> 		}
> 		return single;
> 	}
> }
> ```
>
> >懒汉式暂时还存在线程安全问题，讲到多线程时，可修复

饿汉式：

- 特点：`立即加载`，即在使用类的时候已经将对象创建完毕。
- 优点：实现起来`简单`；没有多线程安全问题。
- 缺点：当类被加载的时候，会初始化static的实例，静态变量被创建并分配内存空间，从这以后，这个static的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会`耗费内存`。

懒汉式：

- 特点：`延迟加载`，即在调用静态方法时实例才被创建。
- 优点：实现起来比较简单；当类被加载的时候，static的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会`节约内存`。
- 缺点：在多线程环境中，这种实现方法是完全错误的，线程不安全，根本不能保证单例的唯一性。
  - 说明：在多线程章节，会将懒汉式改造成线程安全的模式。

> **单例(Singleton)设计模式-`应用场景`**
>
>  **网站的计数器**，一般也是单例模式实现，否则难以同步。
>
>  **应用程序的日志应用**，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
>
>  **数据库连接池**的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。
>
>  项目中，**读取配置文件的类**，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。
>
>  **Application 也是单例的典型应用**
>
>  Windows的**Task Manager** (任务管理器)就是很典型的单例模式
>
>  Windows的**Recycle Bin** (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。





#### 2.5.4 final

在Java中声明类、变量和方法时，可使用关键字final来修饰,表示“最终的”。

- `作用`：
  - final标记的类**不能被继承**。  提高安全性，提高程序的可读性。
        例如：String类、System类、StringBuffer类
  - final标记的方法**不能被子类重写**。
        比如：Object类中的getClass()。
  - final**标记的变量**( 成员变量或局部变量 ) 即**称为常量**。名称大写，且只能被赋值一次。
        例如：final double MY_PI = 3.14;
      final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。
      static final：全局常量

> 举例
>
> ```java
> public final class Test {
> 	public static int totalNumber = 5;
> 	public final int ID;
> 	public Test() {
> 		ID = ++totalNumber; // 可在构造器中给final修饰的“变量”赋值
> 	}
> 	public static void main(String[] args) {
> 		Test t = new Test();
> 		System.out.println(t.ID);
> 		final int I = 10;
> 		final int J;
> 		J = 20;
> 		J = 30; // 非法
> 	}
> }
> ```
>
> 







### 2.6 子类对象实例化过程

![image-20240320003820818](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230413124.png)





### 2.7 面向对象特征

#### 一、封装（encapsulation）

`程序设计追求`：“高内聚，低耦合”。
	**高内聚** ：类的内部数据操作细节自己完成，不允许外部干涉；
	**低耦合** ：仅对外暴露少量的方法用于使用。

<u>`封装性`</u>`的设计思想`：隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。

**`信息的封装和隐藏`**
	Java中通过将数据声明为私有的(private)，再提供公共的（public）方法：**getXxx()**和**setXxx()**实现对该属性的操作，以实现下述目的：
	**隐藏**一个类中不需要对外提供的实现细节；
	使用者只能通过事先定制好的**方法**来**访问数据**，可以方便地加入控制逻辑，限制对属性的不合理操作；
	便于修改，增强代码的可维护性；





#### 二、继承性（inheritance）

子类继承了父类，就继承了父类的方法和属性。

**`名称`**：被继承的类成 **<font color="lightblue">父类(基类或超类)</font>** 继承的类称为 **<font color="lightblue">子类(派生类)</font>**。

**`类继承语法规则`** ：	**class Subclass <font color="red">extends</font> SuperClass{ }**

**为什么要有继承？**
	多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。

**`作用`**：
	继承的出现减少了代码冗余，提高了代码的复用性。
	继承的出现，更有利于功能的扩展。
	继承的出现让类与类之间产生了关系，提供了多态的前提。

**`继承的规则`**：子类不能直接访问父类中私有的(private)的成员变量和方法

注意：
	不要仅为了获取其他类中某个功能而去继承（两个类一定要有关系）
	Java只支持<u>单继承</u>和<u>多层继承</u>，**不允许**<u>多重继承</u>（一个子类只能有一个父类，一个父类可以派生出多个子类）





#### 三、多态性（polymorphism）

`作用`：提高了代码的通用性，常称作接口重用

`前提`：1. 需要存在继承或者实现关系。 2. 有方法的重写。

**成员方法**：
	编译时：要查看引用变量所声明的类中是否有所调用的方法。
	运行时：调用实际new的对象所属的类中的重写方法。

**成员变量**：
	不具备多态性，只看引用变量所声明的类。

多态性是**面向对象中<u>最重要</u>的概念**，在Java中的体现为：
	**对象的多态性：父类的引用指向子类的对象**
		可以直接应用在抽象类和接口上

Java引用变量有两个类型：<font color="red">**编译时类型**</font>和<font color="red">**运行时类型**</font>。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称：**<u>编译时，看左边</u>**；**<u>运行时，看右边</u>**。
	**若编译时类型和运行时类型不一致，就出现了对象的多态性**
	**多态情况下， “看左边” ：**看的是父类的引用（父类中不具备子类特有的方法）
							**“看右边” ：**看的是子类的对象（实际运行的是子类重写父类的方法）



> `虚拟方法调用`(Virtual Method Invocation)
>
> 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。
>
> ```java
> //正常的方法调用
> Person e = new Person();
> e.getInfo();
> Student e = new Student();
> e.getInfo();
> //虚拟方法调用(多态情况下)
> Person e = new Student();
> e.getInfo(); //调用Student类的getInfo()方法
> ```
>
> `编译时类型和运行时类型`
> <font color="red">动态绑定 / 晚绑定</font>：编译时 e 为 Person 类型，而方法的调用是在运行时确定的，所以调用的是 Student 类的 getInfo() 方法。
>
> 举例：Person类中定义了welcome()方法，各个子类重写了welcome()。执行时，多态的情况下，调用对象的welcome()方法，实际执行的是子类重写的方法。



##### 对象类型转换 (Casting )

**基本数据类型**的Casting：
	 自动类型转换：小的数据类型可以自动转换成大的数据类型
		如 ： long g=20;   double d=12.0f
	 强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型
		如 ： float f=(float)12.0;  int a=(int)1200L

对**Java对象**的强制类型转换称为 **“`造型`”**
	 从子类到父类的类型转换（`向上转型`）可以自动进行
	 从父类到子类的类型转换（`向下转型`）必须通过造型(强制类型转换)实现
	 无继承关系的引用类型间的转换是非法的
	 在造型前可以使用 instanceof 操作符测试一个对象的类型

> **对象类型转换**举例
>
> ```java
> public class ConversionTest {
> 	public static void main(String[] args) {
> 		Object obj = "Hello";
> 		String objStr = (String) obj;
> 		System.out.println(objStr);
> 		Object objPri = new Integer(5);
> 		// 下面代码运行时引发ClassCastException异常
>      	// java.lang.Integer and java.lang.String are in module java.base of loader 'bootstrap'
> 		String str = (String) objPri;
> 	}
> }
> 
> ```
>
> ```java
> public class Test {
> 	public void method(Person e) { // 设Person类中没有getschool() 方法
> 		// System.out.pritnln(e.getschool()); //非法,编译时错误
> 		if (e instanceof Student) {
> 			Student me = (Student) e; // 将e强制转换为Student类型
> 			System.out.pritnln(me.getschool());
> 		}
> 	}
> 	public static void main(String[] args){
> 		Test t = new Test();
> 		Student m = new Student();
> 		t.method(m);
> 	}
> }
> ```
>
> 



##### 向上转型与向下转型

  首先，一个对象在new的时候创建是哪个类型的对象，它从头至尾都不会变。即这个对象的运行时类型，本质的类型用于不会变。
  但是，把这个对象赋值给不同类型的变量时，这些变量的编译时类型却不同。

**为什么要类型转换**?
	答：因为多态，就一定会有把子类对象赋值给父类变量的时候，这个时候，在`编译期间`，就会出现类型转换的现象。

但是，使用父类变量接收了子类对象之后，我们就`不能调用`子类拥有，而父类没有的方法了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做类型转换，使得`编译通过`。

<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230413258.png" alt="image-20240320190348601" style="zoom:50%;" />

- **向上转型**：当左边的变量的类型（父类） > 右边对象/变量的类型（子类），我们就称为向上转型
  - 此时，编译时按照左边变量的类型处理，就只能调用父类中有的变量和方法，不能调用子类特有的变量和方法了
  - 但是，**运行时，仍然是对象本身的类型**，所以执行的方法是子类重写的方法体。
  - 此时，一定是安全的，而且也是自动完成的
- **向下转型**：当左边的变量的类型（子类）<右边对象/变量的编译时类型（父类），我们就称为向下转型
  - 此时，编译时按照左边变量的类型处理，就可以调用子类特有的变量和方法了
  - 但是，**运行时，仍然是对象本身的类型**
  - 不是所有通过编译的向下转型都是正确的，可能会发生ClassCastException。为了安全，可以通过**<u>isInstanceof</u>**关键字进行判断



**子类继承父类**

  若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。

  对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量

> `向上转型(upcasting)`：**子类可看做是<u>特殊的父类</u>，所以父类类型的引用可以指向子类的对象：**
>
> **对象的多态** —在Java中,<u>子类的对象</u>可以**替代**<u>父类的对象</u>使用
> 	一个变量只能有一种确定的数据类型
> 	一个引用类型变量可能指向(引用)多种不同类型的对象
>
> ```java
> Person p = new Student();
> Object o = new Person();//Object类型的变量o，指向Person类型的对象
> o = new Student(); //Object类型的变量o，指向Student类型的对象
> ```
>

> `向下转型(downcasting)`：父类可看做是<u>特殊的子类</u>，所以子类类型的引用可以指向父类的对象：
>
> [`面向对象编程中的继承与多态：深入理解父类引用指向子类实例_父类的引用指向子类的实例-CSDN博客`](https://blog.csdn.net/lisainan66/article/details/133135939)
>
> 引用类型**变量**如果声明为父类的类型，但实际引用的是子类对象，那么该变量就<font color="red">不能</font>再访问子类中添加的属性和方法
>
> ```java
> Student m = new Student();
> m.school = “pku”;
> //合法，Student类有school成员变量
> Person e = new Student();
> e.school = “pku”;
> //非法，Person类没有school成员变量
> 属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误
> ```
>
> 
>
> 方法声明的形参类型为**父类**类型，可以使用**子类的对象**作为实参调用该方法。
>
> ```java
> public class Test {
> 	public void method(Person e) {
> 		// ……
> 		e.getInfo();
> 	}
> 	public static void main(Stirng args[]) {
> 		Test t = new Test();
> 		Student m = new Student();
> 		t.method(m); // 子类的对象m传送给父类类型的参数e
> 	}
> }
> ```





##### instanceof 操作符

> 使用语法：x instanceof A  ()
>
> `作用`：检验x是否为类A的对象，返回值为boolean型

要求：
	x所属的类与类A必须是子类和父类的关系，否则编译错误。
	如果x属于类A的子类B，x instanceof A值也为true。

```java
public class Person extends Object {…}
public class Student extends Person {…}
public class Graduate extends Person {…}
-------------------------------------------------------------------
public void method1(Person e) {
	if (e instanceof Person)
		// 处理Person类及其子类对象
	if (e instanceof Student)
		//处理Student类及其子类对象
	if (e instanceof Graduate)
		//处理Graduate类及其子类对象
}
```





### 2.8 Object 类的使用

#### 2.8.1 概述

Object类是所有Java类的**根父类**。每个类都使用 `Object` 作为超类。
如果在类的声明中**未**使用extends关键字指明其父类，则默认父类为java.lang.Object类

- Object类型的变量与除Object以外的任意引用数据类型的对象都存在多态引用

  ```java
  method(Object obj){…} //可以接收任何类作为其参数
  
  Person o = new Person();  
  method(o);
  ```

- 所有对象（包括数组）都实现这个类的方法。



#### 2.8.2 含有方法

| 方法名称                              | 类型 | 描述           |
| ------------------------------------- | ---- | -------------- |
| public Object()                       | 构造 | 构造器         |
| public boolean **equals**(Object obj) | 普通 | 对象比较       |
| public int hashCode()                 | 普通 | 取得Hash码     |
| public String **toString**()          | 普通 | 对象打印时调用 |



##### ==操作符与equals方法

`“= =”运算符`

​		用于引用类型比较引用时，比如比较两个**<u>对象</u>**，则比较<mark>内存地址值</mark>是否相等，只有指向同一个对象时，==才返回true。
​		基本类型比较值:只要两个变量的值相等，即为true。

`equals()方法`

​		所有类都继承了Object，也就获得了 equals() 方法，还可以重写。

​		**比较方式**：除特例外，**只能**比较<u>引用类型</u>，其作用与“==”相同, 比较是否指向同一个对象。
​		**特例**：当用 equals() 方法进行比较时，对类 File 、 String 、 Date 及包装类（ Wrapper Class ）来说，是比较类型及内容而不考虑引用的是否是同一个对象；原因：在这些类中重写了Object类的 equals() 方法。

- **重写**equals()方法的`原则`
  - 对称性：如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是“true”。
  - 自反性：x.equals(x)必须返回是“true”。
  - 传递性：如果x.equals(y)返回是“true” ，而且y.equals(z)返回是“true” ，那么z.equals(x)也应该返回是“true”.
  - 一致性：如果x.equals(y)返回是“true” ，只要x和y内容一直不变，不管重复x.equals(y)多少次，返回都是“true”.
  - 任何情况下，x.equals(null)，永远返回是“false” ；
    x.equals(和x不同类型的对象)永远返回是“false”。

`==和equals的区别`

1 == 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址

2 equals 的话，它是属于 java.lang.Object 类里面的方法，如果该方法没有被重写过默认也是 ==; 我们可以看到String等类的 equals 方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了 equals是比较值的错误观点。

3 具体要看自定义类里有没有重写 Object 的 equals 方法来判断。

4 通常情况下，重写 equals 方法，会比较类中的相应属性是否都相等。

> 举例
>
> ```java
> int it = 65;
> float fl = 65.0f;
> System.out.println(“65和65.0f是否相等？” + (it == fl)); //true
> //------------------------------------------------------------------------------------------
> char ch1 = 'A'; char ch2 = 12;
> System.out.println("65和'A'是否相等？" + (it == ch1)); //true
> System.out.println("12和ch2是否相等？" + (12 == ch2) );//true
> //------------------------------------------------------------------------------------------
> String str1 = new String("hello");
> String str2 = new String("hello");
> System.out.println("str1和str2是否相等？"+ (str1 == str2)); //false
> 
> System.out.println("str1是否equals str2？"+(str1.equals(str2))); //true
> //------------------------------------------------------------------------------------------
> System.out.println(“hello” == new java.util.Date()); //编译不通过
> ```
>
> 



##### toString() 方法

> 方法签名：public String toString()

默认情况下，其返回值是String类型，返回类名和它的引用地址（“对象的运行时类型 @ 对象的hashCode值的十六进制形式”）。

在进行String与**其它类型数据**的**连接操作**时，自动调用toString()方法

如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()

```java
System.out.println(“now=”+now);  
//相当于
System.out.println(“now=”+now.toString()); 
```

可以根据需要在用户自定义类型中重写toString()方法



##### clone()方法

```JAVA
//Object类的clone()的使用
public class CloneTest {
	public static void main(String[] args) {
		Animal a1 = new Animal("花花");
		try {
			Animal a2 = (Animal) a1.clone();
			System.out.println("原始对象：" + a1);
			a2.setName("毛毛");
			System.out.println("clone之后的对象：" + a2);
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
	}
}

class Animal implements Cloneable{
	private String name;

	public Animal() {
		super();
	}

	public Animal(String name) {
		super();
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "Animal [name=" + name + "]";
	}
	
	@Override
	protected Object clone() throws CloneNotSupportedException {
		// TODO Auto-generated method stub
		return super.clone();
	}
	
}
```



##### finalize() 方法

- 当对象被回收时，系统自动调用该对象的 finalize() 方法。（不是垃圾回收器调用的，是本类对象调用的）
  - 永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。
- 什么时候被回收：当某个对象没有任何引用时，JVM就认为这个对象是垃圾对象，就会在之后不确定的时间使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize()方法。
- 子类可以重写该方法，目的是在对象被清理之前执行必要的清理操作。比如，在方法内断开相关连接资源。
  - 如果重写该方法，让一个新的引用变量重新引用该对象，则会重新激活对象。
- 在JDK 9中此方法已经被`标记为过时`的。

```java
public class FinalizeTest {
	public static void main(String[] args) {
		Person p = new Person("Peter", 12);
		System.out.println(p);
		p = null;//此时对象实体就是垃圾对象，等待被回收。但时间不确定。
		System.gc();//强制性释放空间
	}
}

class Person{
	private String name;
	private int age;

	public Person(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	//子类重写此方法，可在释放对象前进行某些操作
	@Override
	protected void finalize() throws Throwable {
		System.out.println("对象被释放--->" + this);
	}
	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}
	
}
```



##### getClass() 方法

> public final Class<?> getClass()    //获取对象的运行时类型

因为Java有多态现象，所以一个引用数据类型的变量的编译时类型与运行时类型可能不一致，因此如果需要查看这个变量实际指向的对象的类型，需要用getClass()方法



##### hashCode() 方法

> public int hashCode()：返回每个对象的hash值。(后续在集合框架章节重点讲解)



##### native关键字的理解

使用native关键字说明这个方法是原生函数，也就是这个方法是用`C/C++`等非Java语言实现的，并且`被编译成了DLL`，由Java去调用。

- 本地方法是有方法体的，用c语言编写。由于本地方法的方法体源码没有对我们开源，所以我们看不到方法体
- 在Java中定义一个native方法时，并不提供实现体。

**1. 为什么要用native方法**

Java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，例如：Java需要与一些底层操作系统或某些硬件交换信息时的情况。native方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。

**2. native声明的方法，对于调用者，可以当做和其他Java方法一样使用**

native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。















### 2.9 UML类图

<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230413391.png" alt="image-20240316164240827" style="zoom:45%;" />





### 2.10 JUnit单元测试

**`介绍`**  JUnit 是由 Erich Gamma 和 Kent Beck 编写的一个测试框架（regression testing framework），供Java开发人员编写单元测试之用。

**JUnit测试是程序员测试，即所谓白盒测试，因为程序员知道被测试的软件如何（How）完成功能和完成什么样（What）的功能。**

要使用JUnit，必须在项目的编译路径中`引入JUnit的库`，即相关的.class文件组成的jar包。jar就是一个压缩包，压缩包都是开发好的第三方（Oracle公司第一方，我们自己第二方，其他都是第三方）工具类，都是以class文件形式存在的。



**`测试分类`**

**黑盒测试：**不需要写代码，给输入值，看程序是否能够输出期望的值。

**白盒测试：**需要写代码的。关注程序具体的执行流程。

<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230413930.png" alt="img" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230413562.png" alt="img"  />



**引入本地JUnit.jar**

需要的包：<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230413360.png" alt="image-20240328223219367" style="zoom: 67%;" />

第1步：在项目中File-Project Structure中操作：添加Libraries库

<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230413742.png" alt="img" style="zoom: 80%;" />

<img src="https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230413213.png" alt="img" style="zoom:80%;" />

其中，junit-libs包内容如下：

![img](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230414152.png)

第2步：选择要在哪些module中应用JUnit库

![img](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230414607.png)

第3步：检查是否应用成功

![img](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230414553.png)

注意Scope：选择Compile，否则编译时，无法使用JUnit。

第4步：下次如果有新的模块要使用该libs库，这样操作即可

![img](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230414045.png)

![img](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230414744.png)

![img](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230414893.png)

![img](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409230414840.png)



**编写和运行@Test单元测试方法**

JUnit4版本，要求@Test标记的方法必须满足如下要求：

- 所在的类**必须**是public的，非抽象的，**包含唯一**的无参构造器。
- @Test标记的方法本身必须是public，非抽象的，非静态s的，void无返回值，()无参数的。



默认情况下Scanner失效（百度）



