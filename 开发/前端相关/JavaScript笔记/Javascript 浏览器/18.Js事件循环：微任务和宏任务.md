[TOC]

------

<center><font size=7><b>JavaScript 事件循环：微任务和宏任务</center></font></center>



## 浏览器和 Node.js 中的事件循环

在浏览器和 Node.js 中，JavaScript 的执行流程都是基于**事件循环**（Event Loop）机制的。了解事件循环的工作原理对于代码优化、提高性能、以及设计合理的架构至关重要，尤其是在处理异步任务时。通过掌握事件循环，我们可以更好地调控任务的执行顺序，避免阻塞主线程，确保应用能够流畅响应用户操作。



## 事件循环的核心概念

**事件循环**的工作原理可以简单概括为：引擎处于一种不断轮询任务队列的循环状态，当有任务时就执行，没有任务时就进入休眠状态。这个机制使得 JavaScript 能够处理异步操作，例如响应用户事件、处理网络请求等，而不会阻塞主线程。

事件循环的工作流程大致如下：

1. **有任务时**：从队列中取出最先到达的任务并执行。
2. **休眠状态**：如果当前没有任务，事件循环会进入休眠状态，直到新的任务到来时才会继续执行。

这种模式非常适合在浏览器中运行 JavaScript，因为在网页加载和用户交互过程中，JavaScript 引擎大多数时间都处于休眠状态，仅在需要执行脚本或事件处理程序时才会被激活。



### 任务的示例说明

常见的任务类型包括：

- **外部脚本加载完成时**：当 `<script src="...">` 加载完成，任务是执行该脚本。
- **用户事件处理**：例如当用户移动鼠标时，任务是触发 `mousemove` 事件并执行事件处理程序。
- **定时器任务**：当通过 `setTimeout` 设定的时间到达，任务是执行对应的回调函数。
- **网络请求响应**：当网络请求完成时，任务是处理请求的响应。

当引擎正在执行任务时，新的任务会被排入队列等待执行。多个任务被组织成一个**宏任务队列**，这些任务按顺序被处理。



## 事件循环简化版算法

事件循环的工作流程可以概括为以下几个步骤（简化版本与[官方规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)略有不同）：

1. **从宏任务队列**（例如 script）中取出并执行最早的任务。
2. 执行所有微任务：
   - 当微任务队列不为空时：
     - 出队并执行最早的微任务，直到微任务队列为空。
3. **渲染更新**：如果有 DOM 变更或界面更新需求，浏览器将此时渲染变化。
4. **休眠**：如果宏任务队列为空，事件循环将进入休眠状态，等待新任务到来。
5. **重复循环**：一旦有新任务进入队列，事件循环从第 1 步重新开始。



## 宏任务与微任务的调度

在事件循环中，任务被分为两类：**宏任务**和**微任务**。

- **宏任务**：这些任务在主线程上执行，浏览器每次从宏任务队列中依次取出一个任务执行。常见的宏任务调度方法是通过 `setTimeout(f)`，即使延迟设为 0，任务也会在下一个事件循环中执行。这种方式常用于将繁重的计算任务分割为多次执行，避免阻塞主线程，从而使浏览器有机会响应用户交互，并且能够在各次任务之间更新界面。

  示例：

  - `setTimeout(() => { console.log('宏任务'); }, 0);`

- **微任务**：微任务仅来自于我们的代码。微任务比宏任务优先执行，当宏任务结束后，会立即执行所有微任务队列中的任务。微任务的典型调度方式是 `queueMicrotask(f)`，同时 `Promise` 的 `then/catch/finally` 处理器也会通过微任务队列执行。微任务会在执行任何其他事件处理，或渲染，或执行任何其他宏任务之前完成，它确保了微任务之间的应用程序环境基本相同（没有鼠标坐标更改，没有新的网络数据等）。因此微任务通常用于保证任务在当前上下文状态一致的情况下异步执行。

  示例：

  - `queueMicrotask(() => { console.log('微任务'); });`
  - `Promise.resolve().then(() => { console.log('微任务'); });`

> 例如，看看下面这个示例：
>
> ```javascript
> setTimeout(() => alert("timeout"));
> 
> Promise.resolve()
>   .then(() => alert("promise"));
> 
> alert("code");
> ```
>
> 执行顺序：（顺序是从上到下，即：首先是脚本，然后是微任务，渲染等）
>
> 1. `code` 首先显示，因为它是常规的同步调用。
> 2. `promise` 第二个出现，因为 `then` 会通过微任务队列，并在当前代码之后执行。
> 3. `timeout` 最后显示，因为它是一个宏任务。
>
> ![image-20241006144006303](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202410061440502.png)
>
> 如果我们想要异步执行（在当前代码之后）一个函数，但是要在更改被渲染或新事件被处理之前执行，那么我们可以使用 `queueMicrotask` 来对其进行安排（schedule）。
>
> 这是一个与前面那个例子类似的，带有“计数进度条”的示例，但是它使用了 `queueMicrotask` 而不是 `setTimeout`。你可以看到它在最后才渲染。就像写的是同步代码一样：
>
> ```html
> <div id="progress"></div>
> 
> <script>
>   let i = 0;
> 
>   function count() {
>     // 做繁重的任务的一部分 (*)
>     do {
>       i++;
>       progress.innerHTML = i;
>     } while (i % 1e3 != 0);
> 
>     if (i < 1e6) {
>       queueMicrotask(count);
>     }
>   }
> 
>   count();
> </script>
> ```



## 注意事项：长时间任务与 UI 更新

在事件循环中有两个重要的注意点：

1. **引擎在执行任务时不会进行渲染**：如果一个任务需要较长时间来完成，例如复杂的计算，那么在任务执行完毕之前，浏览器不会更新用户界面。这意味着如果任务过于耗时，用户可能无法看到 UI 的变化或进行交互。
2. **长时间任务会阻塞用户操作**：如果任务执行时间过长，浏览器将无法响应用户输入。此时，用户可能会看到“页面未响应”的警告。为了避免这种情况，应将复杂的任务分割为多个小块，并通过 `setTimeout` 或 `requestAnimationFrame` 等方式将它们分散到多个事件循环中执行，从而让浏览器有机会在每次任务执行之间更新界面或处理用户事件。





## Web Workers

对于不应该阻塞事件循环的耗时长的繁重计算任务，我们可以使用 [Web Workers](https://html.spec.whatwg.org/multipage/workers.html)。

这是在另一个并行线程中运行代码的方式。

Web Workers 可以与主线程交换消息，但是它们具有自己的变量和事件循环。

Web Workers 没有访问 DOM 的权限，因此，它们对于同时使用多个 CPU 内核的计算非常有用。





## 用例

### 拆分 CPU 过载任务

假设我们有一个 CPU 过载任务。

> 例如，语法高亮（用来给本页面中的示例代码着色）是相当耗费 CPU 资源的任务。为了高亮显示代码，它执行分析，创建很多着了色的元素，然后将它们添加到文档中 —— 对于文本量大的文档来说，需要耗费很长时间。
>
> 当引擎忙于语法高亮时，它就无法处理其他 DOM 相关的工作，例如处理用户事件等。它甚至可能会导致浏览器“中断（hiccup）”甚至“挂起（hang）”一段时间，这是不可接受的。
>
> 我们可以通过将大任务拆分成多个小任务来避免这个问题。高亮显示前 100 行，然后使用 `setTimeout`（延时参数为 0）来安排（schedule）后 100 行的高亮显示，依此类推。

为了演示这种方法，简单起见，让我们写一个从 `1` 数到 `1000000000` 的函数，而不写文本高亮。

如果运行下面这段代码，会看到引擎会“挂起”一段时间。对于服务端 JS 来说这显而易见，并且如果你在浏览器中运行它，尝试点击页面上其他按钮时，你会发现在计数结束之前不会处理其他事件。

```javascript
let i = 0;

let start = Date.now();

function count() {

  // 做一个繁重的任务
  for (let j = 0; j < 1e9; j++) {
    i++;
  }

  alert("Done in " + (Date.now() - start) + 'ms');
}

count();
```

使用嵌套的 `setTimeout` 调用来拆分这个任务：

```javascript
let i = 0;

let start = Date.now();

function count() {

  // 做繁重的任务的一部分 (*)
  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  } else {
    setTimeout(count); // 安排（schedule）新的调用 (**)
  }

}

count();
```

现在，浏览器界面在“计数”过程中可以正常使用。

单次执行 `count` 会完成工作 `(*)` 的一部分，然后根据需要重新安排（schedule）自身的执行 `(**)`：

1. 首先执行计数：`i=1...1000000`。
2. 然后执行计数：`i=1000001..2000000`。
3. ……以此类推。

现在，如果在引擎忙于执行第一部分时出现了一个新的副任务（例如 `onclick` 事件），则该任务会被排入队列，然后在第一部分执行结束时，并在下一部分开始执行前，会执行该副任务。周期性地在两次 `count` 执行期间返回事件循环，这为 JavaScript 引擎提供了足够的“空气”来执行其他操作，以响应其他的用户行为。



值得注意的是这两种变体 —— 是否使用了 `setTimeout` 对任务进行拆分 —— 在执行速度上是相当的。在执行计数的总耗时上没有多少差异。

为了使两者耗时更接近，让我们来做一个改进。

我们将要把调度（scheduling）移动到 `count()` 的开头：

```javascript
let i = 0;

let start = Date.now();

function count() {

  // 将调度（scheduling）移动到开头
  if (i < 1e9 - 1e6) {
    setTimeout(count); // 安排（schedule）新的调用
  }

  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  }

}

count();
```

现在，当我们开始调用 `count()` 时，会看到我们需要对 `count()` 进行更多调用，我们就会在工作前立即安排（schedule）它。

如果你运行它，你很容易注意到它花费的时间明显减少了。

为什么？这很简单：你应该还记得，多个嵌套的 `setTimeout` 调用在浏览器中的最小延迟为 4ms。即使我们设置了 `0`，但还是 `4ms`（或者更久一些）。所以我们安排（schedule）得越早，运行速度也就越快。

最后，我们将一个繁重的任务拆分成了几部分，现在它不会阻塞用户界面了。而且其总耗时并不会长很多。





### 进度指示

对浏览器脚本中的过载型任务进行拆分的另一个好处是，我们可以显示进度指示。

正如前面所提到的，仅在当前运行的任务完成后，才会对 DOM 中的更改进行绘制，无论这个任务运行花费了多长时间。

从一方面讲，这非常好，因为我们的函数可能会创建很多元素，将它们一个接一个地插入到文档中，并更改其样式 —— 访问者不会看到任何未完成的“中间态”内容。很重要，对吧？

如果我们使用 `setTimeout` 将繁重的任务拆分成几部分，那么变化就会被在它们之间绘制出来。

这看起来更好看：

```html
<div id="progress"></div>

<script>
  let i = 0;

  function count() {

    // 做繁重的任务的一部分 (*)
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e6) {
      setTimeout(count);
    }

  }

  count();
</script>
```

现在 `div` 显示了 `i` 的值的增长，这就是进度条的一种。





### 在事件之后做一些事情

在事件处理程序中，我们可能会决定推迟某些行为，直到事件冒泡并在所有级别上得到处理后。我们可以通过将该代码包装到零延迟的 `setTimeout` 中来做到这一点。

自定义事件 `menu-open` 被在 `setTimeout` 中分派（dispatched），所以它在 `click` 事件被处理完成之后发生。

```javascript
menu.onclick = function() {
  // ...

  // 创建一个具有被点击的菜单项的数据的自定义事件
  let customEvent = new CustomEvent("menu-open", {
    bubbles: true
  });

  // 异步分派（dispatch）自定义事件
  setTimeout(() => menu.dispatchEvent(customEvent));
};
```
