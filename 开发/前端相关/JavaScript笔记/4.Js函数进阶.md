[TOC]

------

<center><font size=7><b>JavaScript函数</center></font></center>

---



## Rest 参数与 Spread 语法

### Rest 参数 ...

在 JavaScript 中，无论函数是如何定义的，都可以在调用它时传入任意数量的参数。

这个函数不会因为传入过多的参数而报错。但是只有本应被接收的参数会被接收。

我们可以在函数定义中声明一个数组来收集参数。语法是这样的：`...变量名`，这将会声明一个数组并指定其名称，其中存有剩余的参数。这三个点的语义就是“收集剩余的参数并存进指定数组中”。

```javascript
function sumAll(...args) { // 数组名为 args
  let sum = 0;

  for (let arg of args) sum += arg;

  return sum;
}

alert( sumAll(1, 2, 3) ); // 6
```

注意：**Rest 参数必须放到参数列表的末尾**



### "arguments” 变量

有一个名为 `arguments` 的特殊类数组对象可以在函数中被访问，该对象以参数在参数列表中的索引作为键，存储所有参数。

在过去，JavaScript 中不支持 rest 参数语法，而使用 `arguments` 是获取函数所有参数的唯一方法。

```javascript
function showName() {
  alert( arguments.length );
  alert( arguments[0] );
  alert( arguments[1] );

  // 它是可遍历的
  // for(let arg of arguments) alert(arg);
}

// 依次显示：2，Julius，Caesar
showName("Julius", "Caesar");

// 依次显示：1，Ilya，undefined（没有第二个参数）
showName("Ilya");
```

但缺点是，尽管 `arguments` 是一个类数组，也是可迭代对象，但它终究不是数组。它不支持数组方法，因此我们不能调用 `arguments.map(...)` 等方法。

注意，**箭头函数没有** `"arguments"`。如果我们在箭头函数中访问 `arguments`，访问到的 `arguments` 并不属于箭头函数，而是属于箭头函数外部的“普通”函数。



### Spread 语法

当在函数调用中使用 `...arr` 时，它会把可迭代对象 `arr` “展开”到参数列表中。

```javascript
let arr1 = [3, 5, 1];
alert( Math.max(...arr1) ); // 5（spread 语法把数组转换为参数列表）

// 多个可迭代对象
let arr2 = [8, 3, -8, 1];
alert( Math.max(...arr1, ...arr2) ); // 8

// 与常规值结合使用
alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
```

使用 spread 语法也可以做`Object.assign()`同样的事情（浅拷贝）。

```js
let arrCopy = [...arr]; // 将数组 spread 到参数列表中
```

可以使用 spread 语法来合并数组

```javascript
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

let merged = [0, ...arr, 2, ...arr2];

alert(merged); // 0,3,5,1,2,8,9,15（0，然后是 arr，然后是 2，然后是 arr2）
```

可以用 spread 语法这样操作任何可迭代对象

```javascript
// 将字符串转换为字符数组
let str = "Hello";

alert( [...str] ); // H,e,l,l,o
```



## 变量作用域，闭包

### 词法环境

在 JavaScript 中，每个运行的函数，代码块 `{...}` 以及整个脚本，都有一个被称为 **词法环境（Lexical Environment）** 的内部（隐藏）的关联对象。

词法环境是 JavaScript 引擎用于跟踪和存储变量、函数声明等的一个机制，它定义了在特定执行上下文中哪些变量或函数可以被访问。词法环境通常由两部分组成：

- **环境记录（Environment Record）**：存储所有的局部变量、函数声明以及函数参数。
- **外部词法环境引用（Outer Lexical Environment Reference）**：指向与当前环境相关联的外部环境，这使得 JavaScript 可以查找外层作用域中的变量或函数。

一个“变量”只是 **环境记录** 这个特殊的内部对象的一个属性。“获取或修改变量”意味着“获取或修改词法环境的一个属性”。



### 内部和外部的词法环境

在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。

内部词法环境引用了 `outer`。

当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。
如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。

全局词法环境没有外部引用，所以外部引用指向了 `null`。



### 词法环境的构建

每当执行一段 JavaScript 代码时，JavaScript 引擎会为这段代码创建一个词法环境。这可以发生在以下两种情况下：

- **全局执行上下文**：当 JavaScript 程序开始运行时，会首先创建一个全局的词法环境。全局变量和全局函数都会存储在这个全局词法环境中。
- **函数执行上下文**：当函数被调用时，JavaScript 会为该函数创建一个新的词法环境，存储该函数的局部变量、参数和内部定义的函数。



> 在这个函数调用期间，我们有两个词法环境：内部一个（用于函数调用）和外部一个（全局）：
>
> - 内部词法环境与 `say` 的当前执行相对应。它具有一个单独的属性：`name`，函数的参数。我们调用的是 `say("John")`，所以 `name` 的值为 `"John"`。
> - 外部词法环境是全局词法环境。它具有 `phrase` 变量和函数本身。
>
> ![image-20240923143340849](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409231433888.png)
>
> 搜索过程如下：
>
> - 对于 `name` 变量，当 `say` 中的 `alert` 试图访问 `name` 时，会立即在内部词法环境中找到它。
> - 当它试图访问 `phrase` 时，然而内部没有 `phrase`，所以它顺着对外部词法环境的引用找到了它。



### 词法环境和变量提升

词法环境在代码执行前已经确定了变量和函数的定义位置，这也是为什么 JavaScript 中存在变量提升现象。变量提升指的是，变量声明会在代码执行之前提升到作用域的顶部。

```js
console.log(myVar); // 输出 undefined
var myVar = 10;
```



#### 变量

- 变量是特殊内部对象的属性，与当前正在执行的（代码）块/函数/脚本有关。
- 操作变量实际上是操作该对象的属性。

> 在上面的图片中，矩形表示环境记录（变量存储），箭头表示外部引用。
>
> ![image-20240923142618580](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409231426202.png)
>
> 1. 当脚本开始运行，词法环境预先填充了所有声明的变量。
>    - 最初，它们处于“未初始化（Uninitialized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 `let` 声明前，不能引用它。几乎就像变量不存在一样。
> 2. 然后 `let phrase` 定义出现了。它尚未被赋值，因此它的值为 `undefined`。从这一刻起，我们就可以使用变量了。
> 3. `phrase` 被赋予了一个值。
> 4. `phrase` 的值被修改。



#### 函数声明

与变量不同，函数声明的<u>初始化</u>会被<u>立即完成</u>。

这就是为什么我们甚至可以在声明自身之前调用一个以函数声明（Function Declaration）的方式声明的函数。

> 这是添加一个函数时全局词法环境的初始状态：
>
> ![image-20240923143008107](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409231430150.png)
>
> 正常来说，这种行为仅适用于函数声明，而不适用于我们将函数分配给变量的函数表达式，例如 `let say = function(name)...`。



#### 返回函数

所有的函数在“诞生”时都会记住创建它们的词法环境。

从技术上讲：所有函数都有名为 `[[Environment]]` 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。

与函数被在哪儿调用无关。`[[Environment]]` 引用在函数创建时被设置并永久保存。



举例解释

```js
// 这是一个计数器，调用一次就+1
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
```

在每次 `makeCounter()` 调用的开始，都会创建一个新的词法环境对象，以存储该 `makeCounter` 运行时的变量。（两层嵌套的词法环境）

在执行 `makeCounter()` 的过程中创建了一个仅占一行的嵌套函数：`return count++`。我们尚未运行它，仅定义了它。

`makeCounter()` 被运行时，创建了一个词法环境`{count=0}`，返回的函数被创建，返回的函数记住了该词法环境。

因此，`counter.[[Environment]]` 有对 `{count: 0}` 词法环境的引用。这就是函数记住它创建于何处的方式。

![image-20240923144302376](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202409231443420.png)



### 闭包

**闭包（Closure）** 是 JavaScript 中常见的一种现象，它依赖于词法环境。闭包指的是一个函数“记住”了它创建时的词法环境，并能够在外部函数执行结束后依然访问该词法环境中的变量。



#### 闭包的核心要点

1. **函数嵌套：** 闭包是一个“内嵌”函数，定义在另一个函数内部。
2. **外部变量的访问：** 闭包可以访问定义它的外部函数的变量，即使这个外部函数的执行已经结束。
3. **持久化的环境：** 闭包“记住”了外部函数的变量并能在未来的调用中使用这些变量。它的作用类似于缓存，将外部的上下文环境绑定在一起。



#### 闭包的作用

1. **数据的持久化**： 闭包使得函数在其外部环境销毁后，仍然能够保存一些数据。这在某些情况下非常有用，比如当我们希望创建一个可以“记住”状态的函数时。
2. **模拟私有变量**： JavaScript 中没有内建的私有变量机制，但可以通过闭包模拟私有变量，防止外部访问。



#### 闭包的应用

1. **函数工厂：** 闭包可以用于生成自定义函数。例如，一个函数可以生成另一个带有预设参数的函数。
2. **数据封装：** 闭包可以用于创建私有数据的封装，使得外部无法直接访问这些变量，而只能通过特定的函数接口进行操作。
3. **回调和事件处理：** 闭包可以捕获并保持某些状态信息，在事件或回调函数中使用，非常常见于JavaScript的异步编程中。



#### 闭包的常见问题和陷阱

1. **内存泄漏**： 因为闭包会保留对外部词法环境的引用，有时如果使用不当，可能会导致内存泄漏。特别是在大量使用闭包的场景中，长时间的引用未释放可能会使得一些本该销毁的变量依然占据内存。
2. **循环中的闭包问题**： 闭包在循环中使用时可能会引发一些常见问题，特别是当循环中的每个闭包都访问相同的变量时。



### 垃圾收集

通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除。

JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。

如果从代码中可以明显看出有未使用的外部变量，那么就会将其删除。





## 全局对象

全局对象提供可在任何地方使用的变量和函数。默认情况下，这些全局变量内建于语言或环境中。

| 环境                 | 全局变量的名称 |
| -------------------- | -------------- |
| 浏览器               | window         |
| Node.js              | global         |
| 最近的JavaScript标准 | globalThis     |

全局对象的所有属性都可以被直接访问：

```js
alert("Hello");
// 等同于
window.alert("Hello");
```



在浏览器中，使用 `var`（而不是 `let/const`！）声明的全局函数和变量会成为全局对象的属性。

函数声明（特指在主代码流中具有 `function` 关键字的语句，而不是函数表达式）也有这样的效果。



如果一个值非常重要，以至于你想使它在全局范围内可用，那么可以直接将其作为属性写入：

```js
// 将当前用户信息全局化，以允许所有脚本访问它
window.currentUser = {
  name: "John"
};

// 代码中的另一个位置
alert(currentUser.name);  // John

// 或者，如果我们有一个名为 "currentUser" 的局部变量
// 从 window 显式地获取它（这是安全的！）
alert(window.currentUser.name); // John
```



### 使用 polyfills

我们使用全局对象来测试对现代语言功能的支持。

例如，测试是否存在内建的 `Promise` 对象，如果没有（例如，我们使用的是旧版浏览器），那么我们可以创建 “polyfills”：添加环境不支持但在现代标准中存在的功能。

```js
if (!window.Promise) {
  window.Promise = ... // 定制实现现代语言功能
}
```



## 函数对象，NFE

函数对象包含一些便于使用的属性。

### 属性 “name”

一个函数的名字可以通过属性 “name” 来访问

```js
function sayHi() {
  alert("Hi");
}

alert(sayHi.name); // sayHi
```

名称赋值的逻辑很智能。即使函数被创建时没有名字，名称赋值的逻辑也能给它赋予一个正确的名字，然后进行赋值

规范中把这种特性叫做「上下文命名」。如果函数自己没有提供，那么在赋值中，会根据上下文来推测一个。

```js
let sayHi = function() {
  alert("Hi");
};

alert(sayHi.name); // sayHi（有名字！）
```

```js
let user = {
  sayBye: function() {
    // ...
  }
}

alert(user.sayBye.name); // sayBye
```



### 属性 “length”

返回函数入参的个数

```js
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2   注意 rest 参数不参与计数。
```

属性 `length` 有时在操作其它函数的函数中用于做 内省/运行时检查（introspection）。

> 
