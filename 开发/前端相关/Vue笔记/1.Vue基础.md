

[TOC]
------

<center><font size=7><b> Vue基础——个人笔记 </center></font></center>

---

# Vue

## 简介

**vue2官网**：[Vue.js (vuejs.org)](https://v2.cn.vuejs.org/)

**vue3官网**：[Vue.js - 渐进式 JavaScript 框架 | Vue.js (vuejs.org)](https://cn.vuejs.org/)

- **教程**
  - [开始使用 Vue - 学习 Web 开发 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_getting_started)
  - [Vue3 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/vue3/vue3-tutorial.html)

`Vue` (发音为 /vjuː/，类似 **view**) 是一款用于`构建用户界面`的 JavaScript `渐进式` `框架`。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。

Vue 免除原生JavaScript中的DOM操作，简化书写，提高编程效率。基于MVVM(Model-View-ViewModel)思想，实现数据的双向绑定，将编程的关注点放在数据上。

Vue.js 的核心特点包括`响应式数据绑定`、`组件化开发`、`虚拟DOM`、`双向数据绑定`、`插件扩展能力`以及`简洁易学`的特点。

![1722245988373 (1)](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202407291832720.jpg)

> 构建用户界面：基于数据动态渲染页面
>
> 渐进式：循序渐进的学习。可以一部分一部分学习，由内到外，由小到大，不用全部学习之后才能使用
>
> 框架：是一个完整的项目解决方案，又是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。基于框架进行开发，更加快捷、更加高效。

**Vue的使用方式与对应场景**

1. Vue核心包开发：局部模块改造
2. Vue核心包 & Vue 插件 工程化：整站开发

**Vue的特点**

- 对开发者：
  - 优点：大大提升开发效率
  - 缺点：需要理解记忆规则

## Vue开发者工具

- 对应的Vue开发插件：
  - 谷歌 Chrome 浏览器 [Vue.js Devtools_6.6.3_Chrome插件下载_极简插件 (zzzmh.cn)](https://chrome.zzzmh.cn/info/nhdogjmejiglipccpnnnanhbledajbpd)
  - Edge 浏览器 [Vue.js devtools - Microsoft Edge Addons](https://microsoftedge.microsoft.com/addons/detail/vuejs-devtools/olofadcdnkkjdfgjcmjaadnlehnnihnl?hl=zh-CN)

安装成功后，点击进入Vue.js devtools插件的详细管理页面 [谷歌：详细信息]/[Edge：管理拓展] ，勾选**允许访问文件URL/网址**.

重启浏览器后，按F12，更多工具中找到Vue选项，即可开始使用Vue的开发者工具。

> 注意，需要Vue运行的页面才能使用该调试工具



---

# Vue2 速通

Vue2当前已经停止更新，学习Vue2有利于老项目的兼容与更方便的学习Vue3

## 创建Vue实例

### 步骤

1.  准备容器
2.  引包（开发版本包 / 生产版本包）
3.  创建实例
4.  添加配置项  —》 完成渲染

#### 1.准备容器

在html中，创立Vue所管理的区域

```html
<div id="app">
    <!-- 将来编写一些用来渲染的代码 -->
</div>
```

#### 2.引包

查看官网，了解安装流程，同时获取安装文件：[安装 — Vue.js (vuejs.org)](https://v2.cn.vuejs.org/v2/guide/installation.html)

**用命令行工具(CLI)**

见官方文档，新手不建议使用

**用 \<script> 引入**

![image-20240730002808435](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202407300028500.png)

下载你需要的版本，然后在 .html 文件相同目录下创建名为vue的文件夹，放入vue.js。

在html文件中输入

```html
<script src="vue/vue.js" type="text/javascript" charset="utf-8"></script>
```

如果只是用来学习，则

```html	
<script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"></script>
```

#### 3.创建实例

在JS代码区域，创建Vue核心对象，定义数据模型

```html
<!-- 引入VueJS核心包后，在全局环境存在Vue构造函数 -->
<script>
    const app = new Vue({
        <!-- .... -->
    })
</script>
```

#### 4.添加配置项

```vue
<div id="app">
    <!-- 编写一些用来渲染的代码 -->
    {{ msg }}
    <!-- 还可以在此处 使用函数、访问元素、拼接字符串 等表达式  -->
    {{ msg.toUpperCase() }}
    {{ msg + " ,World" }}
    <!-- 但不支持 if for 这类的语句：{{ if }} 出现则会出错 -->
</div>

<script src="vue/vue.js" type="text/javascript" charset="utf-8"></script>
<script>
    const app = new Vue({
        // 通过 el 配置选择器，指定Vue管理的是哪个盒子
        el: '#app',
        // 通过 data 提供数据
        data:{
            msg: 'Hello'
            friend
        }
    })
</script>
```



## Vue指令

| **常用指令**            | **作用**                                                    |
| ----------------------- | ----------------------------------------------------------- |
| v-html                  | 将数据以html标签的形式插入网页                              |
| v-bind                  | 为HTML标签绑定属性值，如设置 href , css样式等，可省略为 `:` |
| v-model                 | 在表单元素上创建双向数据绑定                                |
| v-on                    | 为HTML标签绑定事件，可省略为 `@`                            |
| v-if、v-else-if、v-else | 条件性的渲染某元素，判定为true时渲染,否则不渲染             |
| v-show                  | 根据条件展示某元素，区别在于切换的是display属性的值         |
| v-for                   | 列表渲染，遍历容器的元素或者对象的属性                      |



**v-show**

1.**作用**：控制元素显示隐藏
2.**表达式值**： true 显示，false 隐藏
3.**原理**：切换 `display : none` 控制显示隐藏
4.**场景**：**频繁**切换显示隐藏的场景

```html
<div id="app">
	年龄{{age}},经判定为:
	<span v-show="age <= 35">年轻人</span>
	<span v-show="age > 35 & age<=60">中年人</span>
</div>
```



**v-if**
1.**作用**：控制元素显示隐藏（条件渲染)
2.**表达式值**：true 显示，false 隐藏
3.**原理**：基于条件判断，是否 创建 或 移除 元素节点
4.**场景**：要么显示，要么隐藏，不频繁切换的场景

```html
<div id="app">
    年龄{{age}},经判定为:
    <span v-if="age <= 35">年轻人</span>
    <span v-else-if="age > 35 && age < 60">中年人</span>
    <span v-else>老年人</span>
</div>
```



**v-on**
1.**作用**：注册事件 = 添加监听提供处理逻辑
2.**语法**：
	v-on:事件名="内联语句 / methods中的函数名"
	（**简写** @事件名 = "内联语句 / methods中的函数名")

```vue
<div id="app">
	<input type="button" value="按钮" v-on:click="handle()">
	<input type="button" value="按钮" @click="handle()">
</div>
<script>
    new Vue({
        el: "#app",
        data: {
    	//...
        },
        methods: {
            handle:function(){
                alert('我被点击了');
            }
        },
    })
</script>
```



**v-bind**
1.**作用**：动态的设置html的标签属性，如src、url、title 等
2.**简写**：`:`

```html
<div id="app">
	<a v-bind:href="url">百度</a>
	<a :href="url">百度</a>
</div>
<script>
  new Vue({
     el: "#app",
     data: {
        url: "https://www.baidu.com"
     }
  })
</script>
```



**v-for**
**作用**：基于数据循环，多次渲染整个元素→ 数组、对象、数字..

**v-for 中key 的作用**：给元素添加的唯一标识。若不加key，v-for 的默认行为会尝试原地修改元素，属性值可能使用错误 (就地复用)

```html
<div id="app">
	<div v-for="addr in addrs" :key="addr">{{addr}}</div>
	<div v-for="(addr,index) in addrs">{{index + 1}} : {{addr}}</div>

</div>
<script>
  new Vue({
     el: "#app",
     data: {
        addrs: ['北京','上海','广州','深圳','成都','杭州']
     }
  })
</script>
```



**v-model**

**作用**：给 表单元素 使用，双向数据绑定→ 可以快速 获取 或 设置 表单元素内容

```html
<div id="app">
    <!--v-model 可以让数据和视图，形成双向数据绑定
    (1)数据变化，视图自动更新
    (2)视图变化，数据自动更新
    可以快速获取或设置表单元素的内容
    -->
    账户:<input type="text" v-model="username"> <br><br>
    密码:<input type="password" v-model="password"> <br><br>
    <button>登录</button>
    <button>重置</button>
</div>
<script>
    const app = new Vue({
        el:'#app',
        data:{
        	username : '',
        	password: ''
        }
    })
</script>
```



## 生命周期

**生命周期**：指一个对象从创建到销毁的整个过程。
**生命周期的八个阶段**：每触发一个生命周期事件，会自动执行一个生命周期方法(钩子)。

| **状态**      | **阶段周期** |
| ------------- | ------------ |
| beforeCreate  | 创建前       |
| created       | 创建后       |
| beforeMount   | 挂载前       |
| mounted       | 挂载完成     |
| beforeUpdate  | 更新前       |
| updated       | 更新后       |
| beforeDestroy | 销毁前       |
| destroyed     | 销毁后       |

![image-20240801033337190](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202408010333827.png)

**mounted**：挂载完成，Vue初始化成功，HTML页面渲染成功。（发送请求到服务端，加载数据）

```html
<script>
    new Vue({
        el: "#app",
        data: {
        },
        mounted() {
            console.log("Vue挂载完毕,发送请求获取数据");
        },
        methods: {
        },
    })
</script>
```



---

# Vue3

## 简介

2020年9月18日，`Vue.js`发布版`3.0`版本，代号：`One Piece`

### 特点

- 源码升级
  - 使用Proxy代替`defineProperty`实现响应式。
  - 重写虚拟DOM的实现和`Tree-Shaking`。
- 可以更好的支持TypeScript。
- 新的内置组件
  - Teleport、Fragments、Suspense
- Composition API
- 新的全局 API
- 响应性系统
- 模板语法改进
- 渲染机制改进
- 自定义渲染器 API

### 组件风格

- **单文件组件**
  - 在大多数启用了构建工具的 Vue 项目中，我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为**单文件组件** (也被称为 `*.vue` 文件，英文 Single-File Components，缩写为 **SFC**)。顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。
- API 风格
  - **选项式 API (Options API)**
    - 使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 `data`、`methods` 和 `mounted`。选项所定义的属性都会暴露在函数内部的 `this` 上，它会指向当前的组件实例。
  - **组合式 API (Composition API)**
    - 通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与 `<script setup>` 搭配使用。这个 `setup` attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，`<script setup>` 中的导入和顶层变量/函数都能够在模板中直接使用。



## 安装Vue3

1. 安装Node.js

2. 安装vue

   ```bash
   npm install -g -d vue @vue/cli 
   ```

3. 安装官方推荐的vscode插件：

   - Vue Official （旧名叫 Volar）
     - 在功能上 `volar` 和 `vetur` 是一致的，都是针对 `vue` 的插件，但是 `volar` 的功能却要强大得多。



## 创建Vue3工程

### 1.通过 CDN 使用 vue

可以借助 script 标签直接通过 CDN 来使用 Vue：

```html
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
```

当然，也可以下载此文件并自行提供服务。

```html
<!-- 将vue.js文件下载到根目录 -->
<script src="vue.global.js"></script>
```

这里使用 [unpkg](https://unpkg.com/)，但也可以使用任何提供 npm 包服务的 CDN，例如 [jsdelivr](https://www.jsdelivr.com/package/npm/vue) 或 [cdnjs](https://cdnjs.com/libraries/vue)。

通过 CDN 使用 Vue 时，不涉及“构建步骤”。这使得设置更加简单，并且可以用于增强静态的 HTML 或与后端框架集成。

但是将无法使用单文件组件 (SFC) 语法。

**全局构建版本示例**：

```vue
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

<div id="app">{{ message }}</div>

<script>
    const { createApp, ref } = Vue

    createApp({
        setup() {
            const message = ref('Hello vue!')
            return {
                message
            }
        }
    }).mount('#app')
</script>
```

**ES 模块构建版本**：

```vue
<div id="app">{{ message }}</div>

<script type="module">
    import { createApp, ref } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'

    createApp({
        setup() {
            const message = ref('Hello Vue!')
            return {
                message
            }
        }
    }).mount('#app')
</script>
```



### 2.基于 vue-cli 创建

官方文档：[创建一个项目 | Vue CLI (vuejs.org)](https://cli.vuejs.org/zh/guide/creating-a-project.html)

vue-cli 是基于 webpack 的。

> Vue CLI 现已处于维护模式!
>
> 现在官方推荐使用 [`create-vue`](https://github.com/vuejs/create-vue) 来创建基于 [Vite](https://cn.vitejs.dev/) 的新项目。 另外请参考 [Vue 3 工具链指南](https://cn.vuejs.org/guide/scaling-up/tooling.html) 以了解最新的工具推荐。

```bash
## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上
vue --version

## 安装或者升级你的@vue/cli 
npm install -g @vue/cli

## 执行创建命令
vue create vue_test

##  随后选择3.x
##  Choose a version of Vue.js that you want to start the project with (Use arrow keys)
##  > 3.x
##    2.x

## 启动
cd vue_test
npm run serve
```



### 3.基于 vite 创建

`vite` 是新一代前端构建工具

官方文档：[Home | Vite中文网 (vitejs.cn)](https://vitejs.cn/)

优势：

- 轻量快速的热重载（`HMR`），能实现极速的服务启动。

- 对 `TypeScript`、`JSX`、`CSS` 等支持开箱即用。

- 真正的按需编译，不再等待整个应用编译完成。

  - webpack的构建：

    ![image-20241014092735969](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202410140927292.png)

  - vite的构建：

    ![image-20241014092851927](https://raw.githubusercontent.com/Jenlybein/My-Typora-Images/imgs/202410140928185.png)

具体操作（官方教程：[快速上手 | Vue.js (vuejs.org)](https://cn.vuejs.org/guide/quick-start#creating-a-vue-application)）

```bash
## 1.创建命令
npm create vue@latest

## 2.具体配置 （此处为了手动学习和理解，一些配置在构建时候应该选no，在正常使用时候选yes）
## 配置项目名称
√ Project name: vue3_test
## 是否添加TypeScript支持
√ Add TypeScript?  Yes
## 是否添加JSX支持
√ Add JSX Support?  No
## 是否添加路由环境
√ Add Vue Router for Single Page Application development?  No
## 是否添加pinia环境
√ Add Pinia for state management?  No
## 是否添加单元测试
√ Add Vitest for Unit Testing?  No
## 是否添加端到端测试方案
√ Add an End-to-End Testing Solution? » No
## 是否添加ESLint语法检查
√ Add ESLint for code quality?  No
## 是否添加Prettiert代码格式化
√ Add Prettier for code formatting?  No
```



### 初步启动项目

在初始化完毕后，通过终端输入 `npm i` 安装项目所需的资源，安装完成后项目内会生成 `node_modules` 文件夹。

```bash
npm run dev
// ctrl + c 关闭运行
```

初次运行将看到vue自带的主页面。

将src目录内的内容删除，我们实现一个简单的Vue网页（选项式API）。

文件目录结构：

```bash
src:.
│  App.vue
│  main.ts
│
└─components
        Person.vue
```

```ts
// main.ts

// 引入createApp用于创建应用
import {createApp} from 'vue'
// 引入App根组件
import App from './App.vue'

createApp(App).mount('#app')
```

```vue
<!-- App.vue -->

<template>
    <!--html-->
    <div class="app">
        <h1>Vue Test：你好！</h1>
        <Person /> <!--使用组件-->
    </div>
</template>

<script>
// JS 或 TS
import Person from './components/Person.vue'

export default {
    name: 'App', //组件名
    components: { Person } //注册组件
}
</script>

<style>
/* 样式 */
.app {
    background-color: antiquewhite;
    box-shadow: 0 0 10px;
    border-radius: 10px;
    padding: 20px;
}
</style>
```

```vue
<!-- Person.vue -->

<template>
    <div class="person">
        <h2>姓名：{{ name }}</h2>
        <h2>年龄：{{ age }}</h2>
        <button @click="changeName">修改名字</button>
        <button @click="changeAge">年龄+1</button>
        <button @click="showTel">点我查看联系方式</button>
    </div>
</template>

<script lang="ts">
export default {
    name: 'App',
    data() {
        return {
            name: '张三',
            age: 18,
            tel: '13888888888'
        }
    },
    methods: {
        changeName() {
            this.name = prompt("请输入名字", "张三") as string;
        },
        changeAge() {
            this.age += 1
        },
        showTel() {
            alert(this.tel)
        }
    },
}
</script>

<style>
/* 样式 */
.person {
    background-color: lightblue;
    box-shadow: 0 0 10px;
    border-radius: 10px;
    padding: 20px;
}
</style>
```

随后再次启动`npm run dev`，即可看到一个由vue构建的简单页面。



## 项目文件概述

#### Vue 初始项目文件

1. `index.html` ：入口文件

   - 这是 Vue 项目的主入口文件，包含基本的 HTML 结构和项目根元素。

     启动 Vue 项目后，访问网站首页即加载此 HTML 文件。

2. `env.d.ts`文件：

     - TypeScript 的类型声明文件。用于定义环境变量的类型。在使用 TypeScript 开发时，尤其是在 Vite 项目中，这个文件通常位于项目的根目录。它的主要作用是为 TypeScript 提供有关环境变量的类型信息，以便在编译时进行类型检查和在编码时提供自动完成。
       
     - 一个典型的 **env.d.ts** 文件可能包含以下内容：
       
        ```ts
        /// <reference types="vite/client" />
        
        declare module "*.vue" {
            import { DefineComponent } from "vue";
            const component: DefineComponent<{}, {}, any>;
            export default component;
        }
        
        interface ImportMetaEnv {
            readonly VITE_TITLE: string;
            // 可以在此处继续声明其他环境变量
        }
        
        interface ImportMeta {
            readonly env: ImportMetaEnv;
        }
        ```
        
        - 解释：
          - `/// <reference types="vite/client" />`：三斜线指令，用于包含 Vite 客户端的类型声明，允许 TypeScript 识别 Vite 特有的模块。
          - `declare module "*.vue"`：声明 Vue 单文件组件的模块，使 TypeScript 能正确处理这些文件。
          - `interface ImportMetaEnv`：声明自定义的环境变量类型，例如 `VITE_TITLE`。
          - `interface ImportMeta`：扩展 `ImportMeta` 接口，以包含环境变量的类型信息。


3. `vite.config.ts`：Vite 配置文件

   - 用于配置 Vite，定义项目的构建和开发服务器的设置。

   - 示例：

     ```ts
     import { defineConfig } from 'vite';		// 从 Vite 导入 `defineConfig` 方法，用于定义配置。
     import vue from '@vitejs/plugin-vue';		// 导入 Vite 的 Vue 插件。
     
     export default defineConfig({		// 导出配置对象。
         plugins: [vue()],				// 使用 Vue 插件。
         server: {port: 3000},			// 设置开发服务器的端口为 3000。
         build: {outDir: 'dist'}			// 设置构建输出目录为 `dist`。
     });
     ```

4. `tsconfig.json`：TypeScript 配置文件

   - 用于配置 TypeScript 编译器的选项。

   - 示例：

     ```json
     {
       "compilerOptions": {
         "target": "esnext",				// 设置编译目标为最新的 ECMAScript 版本。
         "module": "esnext",				// 设置模块系统为 ESNext。
         "strict": true,						// 启用所有严格类型检查选项。
         "jsx": "preserve",					// 保留 JSX 语法，交由其他工具处理。
         "sourceMap": true,					// 生成源地图文件，便于调试。
         "resolveJsonModule": true,				// 允许导入 JSON 模块。
         "esModuleInterop": true,				// 启用 ECMAScript 模块与 CommonJS 模块之间的互操作性。
         "lib": ["esnext", "dom"],					// 包含 ECMAScript 和 DOM 库。
         "types": ["vite/client"]					// 包含 Vite 客户端的类型声明。
       },
       "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue"]	// 指定要包含在编译中的文件和目录。
     }
     ```

5. `tsconfig.app.json`

   - 用于对应用程序的 TypeScript 编译进行细粒度设置。
6. `tsconfig.node.json`

   - 用于对 Node.js 应用程序的 TypeScript 编译进行细粒度设置。

7. `package.json`：项目配置文件

   - 包含项目的元数据、依赖和脚本。

   - 示例：

     ```json
     {
       "name": "vue-app",				// 项目名称。
       "version": "0.0.1",					// 项目版本。
       "scripts": {							// 定义项目的 npm 脚本。
         "dev": "vite",						// 启动开发服务器。
         "build": "vite build",					// 构建项目。
         "serve": "vite preview"					// 预览构建后的项目。
       },
       "dependencies": {						// 定义项目的生产依赖。
         "vue": "^3.2.0"						// Vue 框架。
       },
       "devDependencies": {					
         "@vitejs/plugin-vue": "^1.2.0",			// Vite 的 Vue 插件。
         "typescript": "^4.3.2",					// TypeScript 语言。
         "vite": "^2.3.0"						// Vite 构建工具。
       }
     }
     ```

7. `package-lock.json`

   - 用于锁定项目依赖版本的文件，确保项目构建一致性。

9. `src/main.ts`：项目主文件

   - 用于创建 Vue 应用实例并挂载到 `index.html` 中定义的根元素。

   - 示例：

     ```ts
     import { createApp } from 'vue';	// 从 Vue 库中导入 createApp 方法。
     import App from './App.vue';		// 导入根组件 App.vue。
     
     createApp(App).mount('#app');		// 创建 Vue 应用实例，并将其挂载到 index.html 中的 #app 元素上。
     ```

9. `src/App.vue`：主组件文件

   - Vue 项目的根组件。
   
   - 示例：
   
     ```vue
     <template>							<!-- 定义组件的模板部分，包含 HTML 结构。-->
     <div id="app">						<!-- 根元素。  -->
         <h1>{{ title }}</h1>				<!-- 显示标题。  -->
         </div>
     </template>
     
     <script lang="ts"> <!-- 定义组件的脚本部分，使用 TypeScript 编写。  -->
         import { defineComponent } from 'vue'; <!--从 Vue 库中导入 defineComponent 方法。-->
     
         export default defineComponent({ 		<!--定义并导出组件。-->
             name: 'App',						<!--组件名称。-->
             data() {							<!-- 定义组件的数据属性 -->
                 return {
                     title: import.meta.env.VITE_TITLE	<!--title 值来自环境变量 VITE_TITLE。-->
                 };
             }
         });
     </script>
     
     <style>
         
         #app {		/*根元素的样式定义。*/
             font-family: Avenir, Helvetica, Arial, sans-serif;
             -webkit-font-smoothing: antialiased;
             -moz-osx-font-smoothing: grayscale;
             text-align: center;
             color: #2c3e50;
             margin-top: 60px;
         }
     </style>
     ```



#### 使用TS定义接口

（此部分建议先速览一遍，看完核心语法，遇到相关内容之后再回来看）

在`src`中创建文件夹`types`，创建文件`index.ts`用于存储定义的接口。

注意：`@`是从项目src目录开始进行读取，名为`index.ts`被读取时候不用写其名字。

```ts
// index.ts
export interface PersonInter {
  id: string;
  name: string;
  age: number;
}
```

```vue
<!-- Person.vue -->
<template>
  <div class="person">
    123
  </div>
</template>

<script lang="ts" setup name="Person">
import { type PersonInter, type Persons } from '@/types'
let person: PersonInter = { id: '123', name: '123', age: 123 }
let arr: Persons = [
  { id: '1', name: '张三', age: 15 },
  { id: '2', name: '李四', age: 16 },
  { id: '3', name: '王五', age: 17 },
]
</script>
```





## 基础语法

### 模板语法

Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。

在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。



### 文本插值

最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 (即双大括号)：

```vue
<span>Message: {{ msg }}</span>
```

双大括号标签会被替换为相应组件实例中 `msg` 属性的值。同时每次 `msg` 属性更改时它也会同步更新。



### 原始 HTML

双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，需要使用 `v-html`

```vue
<p>Using text interpolation: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

在当前组件实例上，将此元素的 innerHTML 与 `rawHtml` 属性保持同步。

`span` 的内容将会被替换为 `rawHtml` 属性的值，插值为纯 HTML——数据绑定将会被忽略。注意，你不能使用 `v-html` 来拼接组合模板，因为 Vue 不是一个基于字符串的模板引擎。在使用 Vue 时，应当使用组件作为 UI 重用和组合的基本单元。

> 安全警告
>
> 在网站上动态渲染任意 HTML 是非常危险的，因为这非常容易造成 [XSS 漏洞](https://zh.wikipedia.org/wiki/跨網站指令碼)。请仅在内容安全可信时再使用 `v-html`，并且**永远不要**使用用户提供的 HTML 内容。



### Attribute 绑定

双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 `v-bind` 指令

```vue
<div v-bind:id="dynamicId"></div>
```

`v-bind` 指令指示 Vue 将元素的 `id` attribute 与组件的 `dynamicId` 属性保持一致。如果绑定的值是 `null` 或者 `undefined`，那么该 attribute 将会从渲染的元素上移除。

#### 简写

因为 `v-bind` 非常常用，我们提供了特定的简写语法：

```vue
<div :id="dynamicId"></div>
```

#### 同名简写

- 仅支持 3.4 版本及以上

如果 attribute 的名称与绑定的 JavaScript 值的名称相同，那么可以进一步简化语法，省略 attribute 值：

```vue
<div v-bind:id="id"></div>
<div :id="id"></div>

<!-- 与 :id="id" 相同 -->
<div :id></div>

<!-- 这也同样有效 -->
<div v-bind:id></div>
```

#### 布尔型 Attribute

依据 true / false 值来决定 attribute 是否应该存在于该元素上。`disabled` 就是最常见的例子之一。

`v-bind` 在这种场景下的行为略有不同：

```vue
<button :disabled="isButtonDisabled">Button</button>
```

当 `isButtonDisabled` 为[真值](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)或一个空字符串 (即 `<button disabled="">`) 时，元素会包含这个 `disabled` attribute。而当其为其他[假值](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)时 attribute 将被忽略。

- `isButtonDisabled` 为 `true`，渲染结果为：

  - ```vue
    <button :disabled="false">Button</button>
    ```

- `isButtonDisabled` 为 `false`，渲染结果为：

  - ```vue
    <button>Button</button>
    ```

#### 动态绑定多个值

如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：

```js
const objectOfAttrs = {
  id: 'container',
  class: 'wrapper',
  style: 'background-color:green'
}
```

通过不带参数的 `v-bind`，你可以将它们绑定到单个元素上：

```vue
<div v-bind="objectOfAttrs"></div>
```



### 使用 JavaScript 表达式

 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式。

这些表达式都会被作为 JavaScript ，以当前组件实例为作用域解析执行。

在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：

- 在文本插值中 (双大括号)
- 在任何 Vue 指令 (以 `v-` 开头的特殊 attribute) attribute 的值中

```vue
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

<div :id="`list-${id}`"></div>
```

每个绑定仅支持**单一表达式**，也就是一段能够被求值的 JavaScript 代码。

一个简单的判断方法是是否可以合法地写在 `return` 后面。

因此，下面的例子都是**无效**的：

```vue
<!-- 这是一个语句，而非表达式 -->
{{ var a = 1 }}

<!-- 条件控制也不支持，请使用三元表达式 -->
{{ if (ok) { return message } }}
```

#### 受限的全局访问

模板中的表达式将被沙盒化，仅能够访问到有限的全局对象列表。

在模板中的表达式可以访问一些常用的内置全局对象，比如：

- `Math`: 提供数学常数和函数，例如 `Math.PI` 和 `Math.random()`.
- `Date`: 提供处理日期和时间的方法，例如 `Date.now()` 和 `new Date()`.

没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 `window` 上的属性。然而，你也可以自行在 `app.config.globalProperties`上显式地添加它们，供所有的 Vue 表达式使用。



### 指令

**完整的指令语法**：

![指令语法图](https://cn.vuejs.org/assets/directive.DtZKvoAo.png)

指令由 `v-` 作为前缀，表明它们是一些由 Vue 提供的特殊 attribute，你可能已经猜到了，它们将为渲染的 DOM 应用特殊的响应式行为。

指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外: `v-for`、`v-on` 和 `v-slot`)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。

> 以 `v-if`为例：
>
> ```vue
> <p v-if="seen">Now you see me</p>
> ```
>
> 这里，`v-if` 指令会基于表达式 `seen` 的值的真假来移除/插入该 `<p>` 元素。

#### 参数 Arguments

某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。

> 例如用 `v-bind` 指令来响应式地更新一个 HTML attribute：
>
> ```vue
> <a v-bind:href="url"> ... </a>
> 
> <!-- 简写 -->
> <a :href="url"> ... </a>
> ```
>
> 这里 `href` 就是一个参数，它告诉 `v-bind` 指令将表达式 `url` 的值绑定到元素的 `href` attribute 上。在简写中，参数前的一切 (例如 `v-bind:`) 都会被缩略为一个 `:` 字符。
>
> 另一个例子是 `v-on` 指令，它将监听 DOM 事件：
>
> ```vue
> <a v-on:click="doSomething"> ... </a>
> 
> <!-- 简写 -->
> <a @click="doSomething"> ... </a>
> ```
>
> 这里的参数是要监听的事件名称：`click`。`v-on` 有一个相应的缩写，即 `@` 字符。我们之后也会讨论关于事件处理的更多细节。

#### 动态参数

同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内。

> ```vue
> <a v-bind:[attributeName]="url"> ... </a>
> 
> <!-- 简写 -->
> <a :[attributeName]="url"> ... </a>
> ```
>
> 这里的 `attributeName` 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。
>
> 举例来说，如果你的组件实例有一个数据属性 `attributeName`，其值为 `"href"`，那么这个绑定就等价于 `v-bind:href`。

> 相似地，你还可以将一个函数绑定到动态的事件名称上：
>
> ```vue
> <a v-on:[eventName]="doSomething"> ... </a>
> 
> <!-- 简写 -->
> <a @[eventName]="doSomething"> ... </a>
> ```
>
> 在此示例中，当 `eventName` 的值是 `"focus"` 时，`v-on:[eventName]` 就等价于 `v-on:focus`。

##### 动态参数值的限制

动态参数中表达式的值应当是一个字符串，或者是 `null`。特殊值 `null` 意为显式移除该绑定。其他非字符串的值会触发警告。

##### 动态参数语法的限制

动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。

如果需要传入一个复杂的动态参数，推荐使用计算属性替换复杂的表达式。

> 例如下面的示例：
>
> ```vue
> <!-- 这会触发一个编译器警告 -->
> <a :['foo' + bar]="value"> ... </a>
> ```

当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写。

> ```vue
> <a :[someAttr]="value"> ... </a>
> ```
>
> 上面的例子将会在 DOM 内嵌模板中被转换为 `:[someattr]`。如果你的组件拥有 “someAttr” 属性而非 “someattr”，这段代码将不会工作。
>
> 单文件组件内的模板**不**受此限制。

#### 修饰符 Modifiers

修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。

> 例如 `.prevent` 修饰符会告知 `v-on` 指令对触发的事件调用 `event.preventDefault()`：
>
> ```vue
> <form @submit.prevent="onSubmit">...</form>
> ```





## 核心语法

### OptionsAPI 与 CompositionAPI

- `Vue2`的`API`设计是`Options`（配置）风格的。
- `Vue3`的`API`设计是`Composition`（组合）风格的。

#### Options API 的弊端

`Options`类型的 `API`，数据、方法、计算属性等，是分散在：`data`、`methods`、`computed`中的，若想新增或者修改一个需求，就需要分别修改：`data`、`methods`、`computed`，不便于维护和复用。

```js
export default{
    data(){
        return{
            //功能A...
            //功能B...
            //...
        }
    },
    methods:{
            //功能A...
            //功能B...
            //...
    },
    computed:{
            //功能A...
            //功能B...
            //...
    },
    watch:{
            //功能A...
            //功能B...
            //...
    }
}
```

内容分散，每次添加功能都要在各部分写上对应内容，不利于维护。

#### CompositionAPI 优势

可以用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。

每一个功能对应一个function，而不用每写一个功能跨越四个部分。



### setup

#### setup 概述

在 Vue 3 中，`setup` 是组合式 API（Composition API）的核心部分，它允许你在一个函数中组织组件的逻辑，而不是在选项对象中。

特点如下：

- `setup`函数返回的对象中的内容，可直接在模板中使用。
- `setup`中访问`this`是`undefined`。
- `setup`函数会在`beforeCreate`之前调用，它是“领先”所有钩子执行的，位于生命周期最开始的位置。
- 组件中所用到的均配置在`setup`中：数据（data）、方法（methods）、计算属性（computed）、监视（watch）、...。

使用：

- setup接收两个参数：
  1. `props`：一个对象，包含传递给组件的所有 props。
  2. `context`：一个对象，包含 `attrs`、`slots` 和 `emit` 三个属性。

- setup 函数的返回值：

  - 若返回一个**对象**：则对象中的：属性、方法等，在模板中均可以直接使用。类似于选项式 API 中的 `data` 和 `methods`。

    - 

  - 若返回一个**函数**：则可以自定义渲染内容。

    - 示例代码如下：

      ```jsx
      setup(){
        return ()=> '你好啊！'
      }
      ```

- 属性方法定义：

  - 直接在`setup()`的代码块`{}`内定义的属性，不是响应式的。
  - 若要使用响应式特性，需声明`ref()`。

##### setup 与 Options API 的关系

- `setup`函数会在`beforeCreate`之前调用，领先于`data`、`methos`。
  - `Vue2` 的配置（`data`、`methos`......）中**可以访问到** `setup`中的属性、方法。（使用this.属性)
  - 但在`setup`中**不能访问到**`Vue2`的配置（`data`、`methos`......）。
- 两种语法可共存，但如果产生冲突，则`setup`优先。

#### setup 语法糖

`<script setup>` 是 Vue 3.2 引入的一种语法糖，旨在简化和优化组件的定义方式。它使得组件的定义更加直观和简洁。

1. **无需 `export default`**：
   - 使用 `<script setup>` 后，不再需要显式地导出组件定义。Vue 会自动处理这一部分。
2. **直接使用响应式变量和方法**：
   - 在 `<script setup>` 中定义的变量和方法，可以直接在模板中使用，无需返回它们。
3. **自动解析模板引用**：
   - 模板中引用的变量和方法，Vue 会自动解析并绑定，无需显式地进行绑定操作。
   - 这使得代码更加简洁和直观。
4. **组合式 API 更加简洁**：
   - `setup` 函数中的组合式 API (Composition API) 使用 `<script setup>` 语法糖后，不需要显式地写 `return` 语句。
   - 这减少了样板代码，使逻辑结构更加清晰。



#### 指定组件名字

组件的名字是文件名，若要在代码中另外指定组件名字，一般需要定义name属性。

```vue
<script lang="ts">
    export default{
        name:'Person234',
        setup(){/*...*/}
    }
</script>
```

若使用 `<script setup>`，则无法用 `export`，所以需另外开一个不带 `setup`的 `<script>`来定义组件名。

我们可以借助`vite`中的插件简化，使 `<script setup>`也能改组件名：

1. 安装插件：终端输入`npm i vite-plugin-vue-setup-extend -D`

2. 修改配置文件：`vite.config.ts`，文件内对应位置加入以下内容：

   ```ts
   import VueSetupExtend from 'vite-plugin-vue-setup-extend'
   
   export default defineConfig({
     plugins: [ VueSetupExtend() ]
   })
   ```

3. 修改标签，添加组件名：`<script setup lang="ts" name="Person">`



### 声明响应式状态

#### ref()

在组合式 API 中，推荐使用 `ref()` 函数来声明响应式状态。

`ref()` 接收参数，并将其包裹在一个带有 `.value` 属性的 ref 对象中返回。

- **语法：**`let xxx = ref(初始值)`。
- **接收参数**：`ref`接收的数据可以是**基本类型**、**对象类型**。
- **返回值：**一个`RefImpl`的实例对象，简称`ref对象`或`ref`，`ref`对象的`value`**属性是响应式的**。
- **注意点：**
  - `JS`中操作数据需要：`xxx.value`，但模板中不需要`.value`，直接使用即可。
  - 对于`let name = ref('张三')`来说，`name`不是响应式的，`name.value`是响应式的。

当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。当一个组件首次渲染时，Vue 会**追踪**在渲染过程中使用的每一个 ref。然后，当一个 ref 被修改时，它会**触发**追踪它的组件的一次重新渲染。

在标准的 JavaScript 中，检测普通变量的访问或修改是行不通的。然而，我们可以通过 getter 和 setter 方法来拦截对象属性的 get 和 set 操作。

该 `.value` 属性给予了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。

##### 深层响应性

Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构，比如 `Map`。Ref 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到。

非原始值将通过 `reactive()` 转换为响应式代理。这意味着对象或数组中的每一个嵌套层级都会被 Vue 处理成响应式的，确保任何层级的变化都能被检测到。

也可以通过 `shallow ref` 来放弃深层响应性。

有时候我们并不需要这种深层响应性，可以通过 `shallowRef` 来放弃深层响应性。对于浅层 ref，只有 `.value` 的访问会被追踪。

##### 示例

**基本类型响应式定义**

```vue
<!--Count.vue-->
<template>
    <div class="count">
        <button @click="increment">
            count目前计数：{{ count }}
        </button>
        <button @click="printlog">
            控制台输出信息
        </button>
    </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
const count = ref(0)

function increment() {
    count.value++
}

function printlog() {
    count.value=1
    console.log(count) // { value: 1 }
    console.log(count.value) // 1
}
</script>
```

**对象类型响应式定义示例**

```vue
<template>
    <div class="Car">
        <h2>汽车信息：一台{{ car.brand }}汽车，价值{{ car.price }}万</h2>
        <button @click="changeCarPrice">汽车价格+10w</button>
    </div>
</template>

<script lang="ts" setup>
import { ref } from 'vue'

let car = ref({ brand: '奔驰', price: 100 })

console.log(car)

function changeCarPrice() {
    car.value.price += 10
}
</script>
```

##### shallow ref示例

```vue
<script setup>
import { shallowRef } from 'vue';

// 创建一个 shallow ref，并赋值一个嵌套对象
const shallowState = shallowRef({
  user: {
    name: 'Bob',
    preferences: {
      theme: 'dark'
    }
  }
});

// 改变嵌套对象的值
shallowState.value.user.preferences.theme = 'light';

// Vue 不会检测到嵌套对象的变化，因为 shallowRef 只追踪 .value 的变化
</script>
```



#### DOM 更新时机

当你修改了响应式状态时，DOM 会被自动更新。但是需要注意的是，DOM 更新不是同步的。Vue 会在“next tick”更新周期中缓冲所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次。

要等待 DOM 更新完成后再执行额外的代码，可以使用 `nextTick()` 全局 API：

```js
import { nextTick } from 'vue'

async function increment() {
  count.value++
  await nextTick()
  // 现在 DOM 已经更新了
}
```



#### reactive

若`ref`接收的是对象类型，内部其实也是调用了`reactive`函数。

- **作用：**定义一个**响应式对象**（基本类型不要用它，要用`ref`，否则报错）
- **语法：**`let 响应式对象= reactive(源对象)`。
- **返回值：**一个`Proxy`的实例对象，简称：响应式对象。
- **注意点：**
  - `reactive`定义的响应式数据是“深层次”的。
  - 用 `reactive`定义的响应式数据不再需要用 `.value`调用对象之后再调用对象的值。
  - 响应式对象是 JavaScript 代理(Proxy)，其行为就和普通对象一样。不同的是，Vue 能够拦截对响应式对象所有属性的访问和修改，以便进行依赖追踪和触发更新。
  - 与浅层 ref 类似，这里也有一个 `shallowReactive()` API 可以选择退出深层响应性。

##### 示例

```vue
<template>
    <div class="Car">
        <h2>汽车信息：一台{{ car.brand }}汽车，价值{{ car.price }}万</h2>
        <button @click="changeCarPrice">汽车价格+10w</button>
    </div>
</template>

<script lang="ts" setup>
import { reactive } from 'vue'

let car = reactive({ brand: '奔驰', price: 100 })

console.log(car)

function changeCarPrice() {
    car.price += 10
}
</script>
```



#### 额外的 ref 解包细节

##### 作为 reactive 对象的属性

一个 ref 会在作为响应式对象的属性被访问或修改时自动解包。换句话说，它的行为就像一个普通的属性：

```js
const count = ref(0)
const state = reactive({
  count
})

console.log(state.count) // 0

state.count = 1
console.log(count.value) // 1
```

如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref：

```js
const otherCount = ref(2)

state.count = otherCount
console.log(state.count) // 2
// 原始 ref 现在已经和 state.count 失去联系
console.log(count.value) // 1
```

只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当其作为`浅层响应式对象`的属性被访问时不会解包。

##### 数组和集合的注意事项

与 reactive 对象不同的是，当 ref 作为响应式数组或原生集合类型 (如 `Map`) 中的元素被访问时，它**不会**被解包：

```js
const books = reactive([ref('Vue 3 Guide')])
// 这里需要 .value
console.log(books[0].value)

const map = reactive(new Map([['count', ref(0)]]))
// 这里需要 .value
console.log(map.get('count').value)
```

##### 在模板中解包的注意事项

在 Vue 的模板渲染上下文中，只有顶级的 `ref` 属性会自动解包，这意味着在模板中使用这些 `ref` 属性时，不需要显式地使用 `.value`。

在下面的例子中，`count` 和 `object` 是顶级属性，但 `object.id` 不是：

```vue
<template>
<!-- 顶级 ref 属性可以直接使用，并且会被自动解包 -->
<p>{{ count + 1 }}</p> <!-- 渲染结果为 1 -->

<!-- 非顶级 ref 属性不会自动解包 -->
<p>{{ object.id + 1 }}</p> <!-- 渲染结果为 [object Object]1 -->
</template>

<script setup>
    import { ref } from 'vue';

    // 定义顶级的 ref 属性
    const count = ref(0);
    // 定义一个对象，其中包含一个 ref 属性
    const object = { id: ref(1) };
</script>
```

为了解决这个问题，我们可以将 `id` 解构为一个顶级属性：

```vue
<template>
<!-- 直接使用解构后的顶级属性 -->
<p>{{ id + 1 }}</p> <!-- 渲染结果为 2 -->
</template>

<script setup>
    import { ref } from 'vue';

    // 定义一个对象，其中包含一个 ref 属性
    const object = { id: ref(1) };

    // 将 id 解构为一个顶级属性
    const { id } = object;
    // 上诉用了js解构赋值语法，若对象只有id一个属性，实际上类似于：const id = object.id;
</script>
```

该特性仅仅是文本插值的一个便利特性，等价于 `{{ object.id.value }}`。



#### ref 与 reactive 对比

- 宏观角度看：

  1. `ref`用来定义：**基本类型数据**、**对象类型数据**；

  2. `reactive`用来定义：**对象类型数据**。

- 区别：

  - `ref`创建的变量必须使用`.value`（可以使用`volar`插件自动添加`.value`）。

  - `reactive`直接访问和修改属性。

  - `ref` 重新分配`.value`，不会失去响应式链接。

    ```js
    // let car = ref({brand:'奔驰',price:100})
    car.value = {brand:'奥拓',price:1}
    ```

  - `reactive`重新分配一个新对象，会**失去**响应式链接（可以使用`Object.assign`去整体替换）。

    ```js
    // let car = reactive({brand:'奔驰',price:100})
    Object.assign(car,{brand:'奥拓',price:1})
    car = {brand:'奥拓',price:1} // 失去链接
    ```

- 使用原则：

  1. 若需要一个基本类型的响应式数据，必须使用`ref`。
  2. 若需要一个响应式对象，层级不深，`ref`、`reactive`都可以。
  3. 若需要一个响应式对象，且层级较深，推荐使用`reactive`。



### 响应式对象属性转换

`toRefs` 和 `toRef` 是 Vue 3 中用于将响应式对象的属性转换为独立的 `ref` 的两个实用函数。这些函数在处理复杂对象和增强代码可读性方面非常有用。

- **toRef** 
  - 用于将一个响应式对象的单个属性转换为 `ref`。这在需要单独处理某个属性而不需要解构整个对象时非常有用。
    - 何时使用：
      - 只需要处理某个特定属性时。
      - 希望单独处理某个属性的响应性。
      - 减少不必要的响应性开销。
- **toRefs**
  - 用于将一个响应式对象的所有属性转换为 `ref`，以便每个属性都可以独立地解构并使用。
    - 何时使用：
      - 需要解构整个对象时。
      - 希望保持所有属性的响应性。
      - 提高代码的可读性和维护性。

示例：

```vue
<template>
    <div class="person">
        <h2>姓名：{{ person.name }}</h2>
        <h2>年龄：{{ person.age }}</h2>
        <h2>性别：{{ person.gender ? "男" : "女" }}</h2>
        <button @click="changeName">修改名字</button>
        <button @click="changeAge">修改年龄</button>
        <button @click="changeGender">修改性别</button>
    </div>
</template>

<script lang="ts" setup name="Person">
import { ref, reactive, toRefs, toRef } from 'vue'

// 数据
let person = reactive({ name: '张三', age: 18, gender: 1 })

// 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力
let { name, gender } = toRefs(person)

// 通过toRef将person对象中的gender属性取出，且依然保持响应式的能力
let age = toRef(person, 'age')

// 方法
function changeName() {
    name.value = prompt("请输入姓名", "张三") as string
}
function changeAge() {
    const input = prompt("请输入年龄", "30");
    age.value = input !== null ? Number(input) : 0;
}
function changeGender() {
    gender.value = (gender.value + 1) % 2
}
</script>
```



### computed 计算属性

模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。

推荐使用**计算属性**来描述依赖响应式状态的复杂逻辑。

计算属性默认是**只读**的。尝试修改一个计算属性时，会收到一个运行时警告。

只在某些特殊场景中可能才需要用到“可写”的属性，可以通过同时提供 `getter` 和 `setter` 来创建

```vue
<!--vue2 中计算属性的用法 -->
<script lang="ts">
    export default {
        computed:{
            /*...*/
        }
    }
</script>
```

```VUE
<!--vue3计算属性示例：输入姓、名，显示全名-->
<template>
    <div class="fullname">
        姓：<input type="text" v-model="firstName"><br>
        名：<input type="text" v-model="lastName"><br>
        全名：<span>{{ fullName }}</span>
    </div>
</template>

<script setup lang="ts">
import {ref, computed} from 'vue'

let firstName = ref("张")
let lastName = ref("三")

let fullName = computed(()=>{
    return firstName.value +" "+ lastName.value
})
</script>
```

```vue
<!-- 通过存取器直接修改全面 -->
<template>
    <div class="fullname">
        <h3>请输入英文名</h3>
        姓：<input type="text" v-model="firstName"><br>
        名：<input type="text" v-model="lastName"><br>
        全名：<span>{{ fullName }}</span><br>
        <input id="fullname" type="text">
        <button @click="changFullName()">通过setter修改全名（空格隔开姓和名）</button>
    </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'

let firstName = ref("zhang")
let lastName = ref("san")

let fullName = computed({
    get() {
        return firstName.value + " " + lastName.value
    },
    set(val) {
        const [str1, str2] = val.split(' ')
        if (str2 !== undefined) {
            firstName.value = str1
            lastName.value = str2
        }
    },
})

function changFullName() {
    const fullNameInput = document.getElementById("fullname") as HTMLInputElement;
    fullName.value = fullNameInput.value;
}
</script>
```



### watch 侦听器

侦听器`watch`用作监视数据的变化（和`Vue2`中的`watch`作用一致）。

在组合式 API 中，我们可以使用 `watch` 函数在每次响应式状态发生变化时触发回调函数。

1. `watch` 的第一个参数是“数据源”，`Vue3`中的`watch`只能监视以下**四种数据**：
   1. `ref`定义的数据。
   2. `reactive`定义的数据。
   3. 函数返回一个值（`getter`函数）。
   4. 一个包含上述内容的数组。
2. `watch`第二个参数是一个回调函数，该回调函数会接收几个参数，用于处理和响应数据的变化。包括：
   1. **newValue**: 变化后的新值。
   2. **oldValue**: 变化前的旧值。
   3. **onCleanup**: 用于注册清理函数，当依赖项再次变化或组件卸载时执行。
   4. **注意**：
      * 若修改的是`ref`定义的对象中的属性，`newValue` 和 `oldValue` 都是新值，因为它们是同一个对象。

      * 若修改整个`ref`定义的对象，`newValue` 是新值， `oldValue` 是旧值，因为不是同一个对象了。
3. `watch`第三个参数为可选项`options`：
   1. `immediate`（即时回调）：布尔值，默认 `false`。如果为 `true`，立即执行回调。
      - `watch` 默认是懒执行的：仅当数据源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。可以通过传入 `immediate: true` 选项来强制侦听器的回调立即执行。
   2. `deep`（深层侦听）：布尔值，默认 `false`。如果为 `true`，深度监听对象内部值的变化。
      - `watch`侦听对象类型数据时，默认监视的是对象的`地址值`，仅当更改对象时才会触发回调。
      - 若想监视对象内部的数据，可以通过传入 `deep: true` 手动开启深度监视。
      - 在 Vue 3.5+ 中，`deep` 选项还可以是一个数字，表示最大遍历深度——即 Vue 应该遍历对象嵌套属性的级数。
   3. `once`（一次侦听）：布尔值，默认 `false`。如果为 `true`，回调只在源变化时触发一次。
   4. `flush`：字符串，指定回调函数的执行时机。可选值：
      - `'pre'`：组件更新之前（默认值）。
      - `'post'`：组件更新之后。
      - `'sync'`：同步执行。
4. `watch` 函数会返回一个停止监听的函数。当调用这个返回的函数时，侦听器就会停止工作。



#### watch使用的几种情况

##### 一、监视 ref 定义的基本类型数据

直接写数据名即可，监视的是其`value`值的改变。

> 下例代码：定义了一个侦听器，侦听sum的值，当sum的值大于等于10则停止监听（利用watch函数返回的stopWatch）。
>
> ```vue
> <template>
>   <div class="person">
>     <h1>情况一：监视 ref 定义的基本类型数据</h1>
>     <h2>当前求和为：{{sum}}</h2>
>     <button @click="changeSum">点我sum+1</button>
>   </div>
> </template>
> 
> <script lang="ts" setup name="Person">
>   import {ref,watch} from 'vue'
>   // 数据
>   let sum = ref(0)
>   // 方法
>   function changeSum(){
>     sum.value += 1
>   }
> 
>   const stopWatch = watch(sum,(newValue,oldValue)=>{
>     console.log('sum变化了',newValue,oldValue)
>     if(newValue >= 10){
>       stopWatch()
>     }
>   })
> </script>
> ```
>

##### 二、监视 ref 定义的对象类型数据

直接写数据名，监视的是对象的`地址值`。若想监视对象内部的数据，要手动开启深度监视。

> 下例代码：定义了一个开启深层侦听的侦听器，侦听person对象，当person的属性或其本身发生变化时，监听器会在控制台输出旧值和新值。
>
> ```vue
> <template>
>     <div class="watch">
>         <h1>情况二：监视 ref 定义的对象类型数据</h1>
>         <h2>姓名：{{ person.name }}</h2>
>         <h2>年龄：{{ person.age }}</h2>
>         <button @click="changeName">修改名字</button>
>         <button @click="changeAge">修改年龄</button>
>         <button @click="changePerson">换人</button>
>     </div>
> </template>
> 
> <script lang="ts" setup name="Person">
> import { ref, watch } from 'vue'
> // 数据
> let person = ref({
>     name: '张三',
>     age: 18
> })
> // 方法
> function changeName() {
>     person.value.name += '~'
> }
> function changeAge() {
>     person.value.age += 1
> }
> function changePerson() {
>     person.value = { name: '李四', age: 90 }
> }
> 
> watch(person, (newValue, oldValue) => {
>     console.log('person变化了', newValue, oldValue)
> }, { deep: true })
> </script>
> ```

##### 三、监视 reactive 定义的对象类型数据

不能更换整个对象，要使用`Object.assign`来克隆对象内容。侦听器reactive默认是开启深度监视的。

> 下例可见侦听器在reactive上的使用，可见不用显式开启deep也能实现深度监视。
>
> ```vue
> <template>
>     <div class="person">
>         <h1>情况三：监视reactive定义的对象类型数据</h1>
>         <h2>姓名：{{ fullname }}</h2>
>         <h2>年龄：{{ person.age }}</h2>
>         <button @click="changeName">修改名字</button>
>         <button @click="changeAge">修改年龄</button>
>         <button @click="changePerson">换人</button>
>     </div>
> </template>
> 
> <script lang="ts" setup name="Person">
> import { computed, reactive, watch } from 'vue'
> // 数据
> let person = reactive({
>     name: {
>         firstname:'zhang',
>         lastname:'san',
>     },
>     age: 18
> })
> let fullname = computed({
>     set(val:string){
>         [person.name.firstname, person.name.lastname] = val.split(' ')
>     },
>     get(){
>         return person.name.firstname +" "+ person.name.lastname;
>     }
> });
> 
> // 方法
> function changeName() {
>     fullname.value = 'li si'
> }
> function changeAge() {
>     person.age += 1
> }
> function changePerson() {
>     Object.assign(person, { name: {firstname:'wang',lastname:'wu',}, age: 80 })
> }
> 
> watch(person, (newValue, oldValue) => {
>     console.log('person变化了', newValue, oldValue)
> })
> </script>
> ```

##### 四、监视 ref 或 reactive 定义的对象类型数据中的某个属性

注意点如下：监视的要是对象里的属性，那么最好写函数式。若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。

1. 若该属性值**不是**【对象类型】，需要在watch的第一个参数中，用函数形式将数据源以return的形式传入。
2. 若该属性值**是**【对象类型】，可直接传入，也可用函数形式，建议写成函数。
   1. 若直接传入，监听的是地址值内的内容，类似于情况三
   2. 若用函数形式，则指向的传入地址值改变，也能观察到。


> 下例，用函数形式传入
>
> ```vue
> <template>
>     <div class="watch">
>         <h1>情况四：监视 ref / reactive 定义的对象类型数据中的某个值</h1>
>         <h2>姓名：{{ person.name }}</h2>
>         <h2>年龄：{{ person.age }}</h2>
>         <h2>汽车：{{ person.car.c1 }}、{{ person.car.c2 }}</h2>
>         <button @click="changeName">改名</button>
>         <button @click="changeAge">改年龄</button>
>         <button @click="changeC1">改第一台车</button>
>         <button @click="changeC2">改第二台车</button>
>         <button @click="changeCar">改整个车对象</button>
>     </div>
> </template>
> 
> <script setup lang="ts">
> import { reactive, watch } from 'vue'
> 
> let person = reactive({
>     name: "张三",
>     age: 18,
>     car: {
>         c1: "奔驰",
>         c2: "宝马",
>     }
> })
> 
> function changeName() {
>     person.name = prompt("名字", "张三") as string
> }
> function changeAge() {
>     const age = prompt("年龄", "18")
>     person.age = age !== null ? Number(age) : 0
> }
> function changeC1() {
>     person.car.c1 = "奥迪"
> }
> function changeC2() {
>     person.car.c2 = "宾利"
> }
> function changeCar() {
>     person.car = { c1: '特斯拉', c2: '比亚迪' }
> }
> //监视响应式对象中的某个属性，且该属性是基本类型的，要写成函数式
> watch(() => person.name, (newValue, oldValue) => {
>     console.log('person.name变化了', newValue, oldValue)
> })
> //该属性是对象类型的，可以直接写，也能写函数，更推荐写函数
> watch(() => person.car, (newValue, oldValue) => {
>     console.log('person.car变化了', newValue, oldValue)
> }, { deep: true })
> </script>
> 
> <style>
> .watch {
>     background-color: lightblue;
>     box-shadow: 0 0 10px;
>     border-radius: 10px;
>     padding: 20px;
> }
> </style>
> ```

##### 五、监视多个数据

监视上述的多个数据，可以使用数组形式。

```ts
watch([() => person.car , () => person.name] , (newValue, oldValue) => {
    console.log('person变化了', newValue, oldValue)
}, { deep: true })
```



#### watchEffect

可以用 `watchEffect` 函数 来简化`watch`的代码。`watchEffect()` 允许我们自动跟踪回调的响应式依赖。

`watchEffect`会立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。

两者对比：

- `watch` 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。
  - 另外，仅在数据源确实改变时才会触发回调。`watch` 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。
- `watchEffect`，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。
  - 这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。

```vue
<template>
  <div class="person">
    <h1>需求：水温达到50℃，或水位达到20cm，则联系服务器</h1>
    <h2 id="demo">水温：{{temp}}</h2>
    <h2>水位：{{height}}</h2>
    <button @click="changePrice">水温+1</button>
    <button @click="changeSum">水位+10</button>
  </div>
</template>

<script lang="ts" setup name="Person">
  import {ref,watch,watchEffect} from 'vue'

  let temp = ref(0)
  let height = ref(0)

  function changePrice(){temp.value += 10}
  function changeSum(){height.value += 1 }

  // 用watch实现，需要明确的指出要监视：temp、height
  watch([temp,height],(value)=>{
    // 从value中获取最新的temp值、height值
    const [newTemp,newHeight] = value
    // 室温达到50℃，或水位达到20cm，立刻联系服务器
    if(newTemp >= 50 || newHeight >= 20){
      console.log('联系服务器')
    }
  })

  // 用watchEffect实现，不用
  const stopWtach = watchEffect(()=>{
    // 室温达到50℃，或水位达到20cm，立刻联系服务器
    if(temp.value >= 50 || height.value >= 20){
      console.log(document.getElementById('demo')?.innerText)
      console.log('联系服务器')
    }
    // 水温达到100，或水位达到50，取消监视
    if(temp.value === 100 || height.value === 50){
      console.log('清理了')
      stopWtach()
    }
  })
</script>
```



#### 副作用清理

有时我们可能会在侦听器中执行副作用，例如异步请求。

但是如果在请求完成之前，数据源发生了变化怎么办？当上一个请求完成时，它仍会使用已经过时的 ID 值触发回调。理想情况下，我们希望能够在数据源变为新值时取消过时的请求。

##### onWatcherCleanup

可以使用 `onWatcherCleanup()` API 来注册一个清理函数，当侦听器失效并准备重新运行时会被调用：

```js
import { watch, onWatcherCleanup } from 'vue'

watch(id, (newId) => {
  const controller = new AbortController()

  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {
    // 回调逻辑
  })

  onWatcherCleanup(() => {
    // 终止过期请求
    controller.abort()
  })
})
```

`onWatcherCleanup` 仅在 Vue 3.5+ 中支持，并且必须在 `watchEffect` 效果函数或 `watch` 回调函数的同步执行期间调用：你不能在异步函数的 `await` 语句之后调用它。

##### onCleanup

作为替代，`onCleanup` 函数还作为第三个参数传递给侦听器回调，以及 `watchEffect` 作用函数的第一个参数：

```js
watch(id, (newId, oldId, onCleanup) => {
  // ...
  onCleanup(() => {
    // 清理逻辑
  })
})

watchEffect((onCleanup) => {
  // ...
  onCleanup(() => {
    // 清理逻辑
  })
})
```

具体示例：

```vue
<template>
  <div>
    <h2>Count: {{ count }}</h2>
    <button @click="increment">Increment</button>
  </div>
</template>

<script lang="ts" setup>
import { ref, watch } from 'vue';

// 定义响应式变量
let count = ref(0);

// 定义方法
function increment() {
  count.value += 1;
}

// 定义监听器，并使用 onCleanup 清理副作用
watch(count, (newValue, oldValue, onCleanup) => {
  console.log(`count changed from ${oldValue} to ${newValue}`);

  // 启动一个定时器，每秒打印一次当前的 count 值
  const interval = setInterval(() => {
    console.log(`Interval running with count: ${newValue}`);
  }, 1000);

  // 注册清理函数，在下一次 count 变化前清除定时器
  onCleanup(() => {
    clearInterval(interval);
    console.log('Interval cleared.');
  });
});
</script>
```



#### 回调的触发时机

当响应式状态（即 Vue 组件中的数据）发生变化时，它可能会同时触发 Vue 组件的更新以及 `watch` 侦听器的回调。

为了避免重复调用，Vue 会对这些更新进行批量处理。例如，如果我们向一个数组同步推入一千个项目，我们可能不希望 `watch` 侦听器触发一千次。这种批量处理会在一个事件循环内合并多次变更，只触发一次回调。

默认情况下，`watch` 侦听器的回调会在父组件更新（如果有）**之后**、所属组件的 DOM 更新**之前**被调用。也就是说，如果你在 `watch` 回调中访问组件的 DOM，它会处于**更新前**的状态。

##### Post Watchers

如果想在侦听器回调中能访问被 Vue 更新**之后**的所属组件的 DOM，你需要指明 `flush: 'post'` 选项：

```js
watch(source, callback, {
  flush: 'post'
})

watchEffect(callback, {
  flush: 'post'
})
```

后置刷新的 `watchEffect()` 有个更方便的别名 `watchPostEffect()`：

```js
import { watchPostEffect } from 'vue'

watchPostEffect(() => {
  /* 在 Vue 更新后执行 */
})
```

##### 同步侦听器

你还可以创建一个同步触发的侦听器，它会在 Vue 进行任何更新之前触发：

```js
watch(source, callback, {
  flush: 'sync'
})

watchEffect(callback, {
  flush: 'sync'
})
```

同步触发的 `watchEffect()` 有个更方便的别名 `watchSyncEffect()`：

```js
import { watchSyncEffect } from 'vue'

watchSyncEffect(() => {
  /* 在响应式数据变化时同步执行 */
})
```

**谨慎使用**：同步侦听器不会进行批处理，每当检测到响应式数据发生变化时就会触发。可以使用它来监视简单的布尔值，但应避免在可能多次同步修改的数据源 (如数组) 上使用。

##### 示例

```vue
<template>
    <div class="count">
        <h2>Count: {{ count }}</h2>
        <button @click="increment">Increment</button>
    </div>
</template>

<script lang="ts" setup>
import { ref, watch, watchEffect, watchPostEffect, watchSyncEffect } from 'vue';

let count = ref(0);

function increment() {
    count.value += 1;
}

// 默认触发
watch(count, (newValue, oldValue) => {
    console.log(`count changed from ${oldValue} to ${newValue} [watch default]`);
});
watchEffect(() => {
    console.log(`count is now ${count.value} [watchEffect default]`);
};

// 后置触发
watch(count, (newValue, oldValue) => {
    console.log(`count changed from ${oldValue} to ${newValue} [watch post]`);
}, { flush: 'post' });

watchPostEffect(() => {
    console.log(`count is now ${count.value} [watchPostEffect post]`);
});

// 同步触发
watch(count, (newValue, oldValue) => {
    console.log(`count changed from ${oldValue} to ${newValue} [watch sync]`);
}, { flush: 'sync' });

watchSyncEffect(() => {
    console.log(`count is now ${count.value} [watchPostEffect sync]`);
});
</script>
```

输出：顺序为 sync->default->post。

```bash
[vite] connected.
Count.vue:36 count changed from 0 to 1 [watch sync]
Count.vue:40 count is now 1 [watchPostEffect sync]
Count.vue:19 count changed from 0 to 1 [watch default]
Count.vue:22 count is now 1 [watchEffect default]
Count.vue:27 count changed from 0 to 1 [watch post]
Count.vue:31 count is now 1 [watchPostEffect post]
```



### 模板引用

虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 `ref` attribute。

#### 标签的 ref 属性

`ref` 是一个特殊的 attribute，它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。这可能很有用，比如说在组件挂载时将焦点设置到一个 input 元素上，或在一个元素上初始化一个第三方库。

* 用在普通`DOM`标签上，获取的是`DOM`节点。

* 用在组件标签上，获取的是组件实例对象。

##### 3.5之前的方法

**普通DOM标签**

```vue
<template>
    <div class="person">
        <h3 ref="title">Vue</h3>
        <input ref="myInput" type="text" placeholder="输入内容"/><br><br>
        <button @click="showLog">点我打印内容</button>
    </div>
</template>

<script lang="ts" setup name="Person">
import { ref } from 'vue'

let title = ref()
let myInput = ref()

function showLog() {
    console.log(title.value)
    console.log(myInput.value.value)
}
</script>
```

**组件标签**

如果一个子组件使用的是选项式 API 或没有使用 `<script setup>`，被引用的组件实例和该子组件的 `this` 完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的 props 和 emit 接口来实现父子组件交互。

有一个例外的情况，使用了 `<script setup>` 的组件是**默认私有**的：一个父组件无法访问到一个使用了 `<script setup>` 的子组件中的任何东西，除非子组件在其中通过 `defineExpose` 宏显式暴露。

```vue
<template>
<Person ref="ren"/>
<button @click="test">测试</button>
</template>

<script lang="ts" setup name="App">
    import Person from './components/Person.vue'
    import {ref} from 'vue'

    let ren = ref()

    function test(){
        console.log(ren.value.name)
        console.log(ren.value.age)
    }
</script>


<!-- 子组件Person.vue中要使用defineExpose暴露内容 -->
<script lang="ts" setup name="Person">
    import {ref,defineExpose} from 'vue'

    let name = ref('张三')
    let age = ref(18)

    // 使用defineExpose将组件中的数据交给外部
    defineExpose({name,age})
</script>
```

##### 3.5之后的方法

要在组合式 API 中获取引用，我们可以使用辅助函数 `useTemplateRef()`。

**普通DOM标签**

```js
// 将以下：
let title = ref()
let myInput = ref()
// 改为：
const title = useTemplateRef("title")
const myInput = useTemplateRef("myInput")
```

**组件标签**

```js
// 将以下：
let ren = ref()
// 改为：
const ren = useTemplateRef("ren")
```

#### 函数模板引用

除了使用字符串值作名字，`ref` attribute 还可以绑定为一个函数，会在每次组件更新时都被调用。使用函数作为 `ref` 允许你在元素被渲染和卸载时执行特定的逻辑。

该函数会收到元素引用作为其第一个参数 el：

- 当组件渲染时，`el` 参数会收到指向当前 DOM 元素的引用。例如，在下面的代码中，`el` 将指向 `<input>` 元素。
- 当这个 DOM 元素被卸载（即从页面中移除）时，函数也会被调用，此时 `el` 将会是 `null`。这可以让你在元素被移除时进行一些清理操作。

```vue
<input :ref="(el) => { /* 将 el 赋值给一个数据属性或 ref 变量 */ }">
```

注意我们这里需要使用动态的 `:ref` 绑定才能够传入一个函数。

当然，也可以绑定一个组件方法而不是内联函数。



### 组件基础

组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。

在实际应用中，组件常常被组织成一个层层嵌套的树状结构。

这和我们嵌套 HTML 元素的方式类似，Vue 实现了自己的组件模型，使我们可以在每个组件内封装自定义内容与逻辑。Vue 同样也能很好地配合原生 Web Component。

当使用构建步骤时，我们一般会将 Vue 组件定义在一个单独的 `.vue` 文件中，这被叫做 **单文件组件** (简称 SFC)。

#### 使用组件

每当使用一个组件，就创建了一个新的**实例**。每一个组件都维护着自己的状态。

在单文件组件中，推荐为子组件使用 `PascalCase` 的标签名，以此来和原生的 HTML 元素作区分。虽然原生 HTML 标签名是不区分大小写的，但 Vue 单文件组件是可以在编译中区分大小写的。我们也可以使用 `/>` 来关闭一个标签。

如果你是直接在 DOM 中书写模板 (例如原生 `<template>` 元素的内容)，模板的编译需要遵从浏览器中 HTML 的解析行为。在这种情况下，你应该需要使用 `kebab-case` 形式并显式地关闭这些组件的标签。

#### 传递 props

Props 是一种特别的 attributes，你可以在组件上声明注册。要使用 props 传递，我们必须在组件的 props 列表上声明它。这里要用到 `defineProps`宏。

`defineProps` 是一个仅 `<script setup>` 中可用的编译宏命令，并不需要显式地导入。声明的 props 会自动暴露给模板。`defineProps` 会返回一个对象，其中包含了可以传递给组件的所有 props。

> 示例：如果我们正在构建一个博客，我们可能需要一个表示博客文章的组件。我们希望所有的博客文章分享相同的视觉布局，但有不同的内容。要实现这样的效果自然必须向组件中传递数据，例如每篇文章标题和内容，这就会使用到 props。
>
> 使用 `v-bind` 语法(`:title="post.title"`) 来传递动态 prop 值。
>
> 使用 ts 接口 进行 props 传入进行限制。
>
> 使用 withDefault 进行传入默认设置（避免没传入值而导致网页为空）。
>
> ```ts
> // types / index.ts
> export interface TitleInter{
>   id: number,
>   title: string,
> }
> 
> export type Titles = Array<TitleInter>
> ```
>
> ```vue
> <!--App.vue-->
> <template>
>     <div class="app">
>         <BlogPost pre='MyBlogs' v-for="post in posts" :key="post.id" :title="post.title" />
>     </div>
> </template>
> 
> <script setup lang="ts">
> import { ref, reactive } from 'vue'
> import { type Titles } from './types';
> import BlogPost from './components/BlogPost.vue'
> 
> const posts = reactive<Titles>([
>     { id: 1, title: 'My journey with Vue' },
>     { id: 2, title: 'Blogging with Vue' },
>     { id: 3, title: 'Why Vue is so fun' }
> ])
> </script>
> 
> <style scoped>
> .app {
>     background-color: antiquewhite;
>     box-shadow: 0 0 10px;
>     border-radius: 10px;
>     padding: 20px;
> }
> </style>
> ```
>
> ```vue
> <!--BlogPost.vue-->
> <template>
>     <div class="blogpost">
>         <h4> {{ pre }} ：{{ title }}</h4>
>     </div><br>
> </template>
> 
> <script setup lang="ts">
> const props = withDefaults(defineProps<{
>     title: string,
>     pre: string,
> }>(), {
>     title: () => "test",
>     pre: () => "Blog"
> })
> </script>
> 
> <style scoped>
> .blogpost {
>     background-color: lightblue;
>     box-shadow: 0 0 10px;
>     border-radius: 10px;
>     padding: 20px;
> }
> </style>
> ```

如果没有使用 `<script setup>`，props 必须以 `props` 选项的方式声明，props 对象会作为 `setup()` 函数的第一个参数被传入：

```js
export default {
  props: ['title'],
  setup(props) {
    console.log(props.title)
  }
}
```



### 生命周期

**生命周期钩子**：`Vue`组件实例在创建时要经历一系列的初始化步骤，在此过程中`Vue`会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子。

规律：生命周期整体分为四个阶段，分别是：**创建、挂载、更新、销毁**，每个阶段都有两个钩子，一前一后。

- `Vue3`的生命周期
  - 创建阶段：`setup`
  - 挂载阶段：`onBeforeMount`、`onMounted`
  - 更新阶段：`onBeforeUpdate`、`onUpdated`
  - 卸载阶段：`onBeforeUnmount`、`onUnmounted`

App会等待子组件挂载完毕之后才挂载完毕，App是最后完成挂载完毕的。

```vue
<!--App.vue-->
<template>
    <div class="app">
        <Person></Person>
    </div>
</template>

<script setup lang="ts">
import { onBeforeMount, onMounted } from 'vue'
import Person from './components/Person.vue';
onBeforeMount(() => {
    console.log('App 挂载之前')
})
onMounted(() => {
    console.log('App 挂载完毕')
})
</script>
```

```vue
<template>
  <div class="person">
    <h2>当前求和为：{{ sum }}</h2>
    <button @click="changeSum">点我sum+1</button>
  </div>
</template>

<script lang="ts" setup name="Person">
import {
  ref,
  onBeforeMount,
  onMounted,
  onBeforeUpdate,
  onUpdated,
  onBeforeUnmount,
  onUnmounted
} from 'vue'

// 数据
let sum = ref(0)
// 方法
function changeSum() {
  sum.value += 1
}
console.log('setup')
// 生命周期钩子
onBeforeMount(() => {
  console.log('挂载之前')
})
onMounted(() => {
  console.log('挂载完毕')
})
onBeforeUpdate(() => {
  console.log('更新之前')
})
onUpdated(() => {
  console.log('更新完毕')
})
onBeforeUnmount(() => {
  console.log('卸载之前')
})
onUnmounted(() => {
  console.log('卸载完毕')
})
</script>
```

输出：

```ts
client:495 [vite] connecting...
App.vue:12 App 挂载之前
Person.vue:18 setup
Person.vue:21 挂载之前
Person.vue:24 挂载完毕
App.vue:15 App 挂载完毕
client:614 [vite] connected.
```

<img src="https://cn.vuejs.org/assets/lifecycle_zh-CN.W0MNXI0C.png" alt="组件生命周期图示" style="zoom: 55%;" />

### 自定义HOOKS

- `hook`—— 本质是一个函数，把`setup`函数中使用的`Composition API`进行了封装，类似于`vue2.x`中的`mixin`。

- 优势：复用代码, 让`setup`中的逻辑更清楚易懂。

在 `src` 中创建一个名为 `hooks`的目录，然后在里面创建 `.ts` 文件，进行 hooks 的定义。

> 例：下面定义了一个获取小狗图片的hooks。其中用到了axios插件（可用fetch替代）。
>
> ```vue
> <template>
>   <img v-for="(url,index) in dogList.urlList" :key="index" :src="(url as string)"> 
>   <span v-show="dogList.isLoading">加载中......</span><br>
>   <button @click="getDog">再来一只狗</button>
> </template>
> 
> <script setup lang="ts">
>   import useDog from '@/hooks/useDog'
> 	
>   let {dogList,getDog} = useDog()
> </script>
> 
> <style>
>   img{
>     height: 100px;
>     margin: 5px;
>   }
> </style>
> ```
>
> ```ts
> // src / hooks / useDog.ts
> import { ref, reactive, onMounted } from "vue";
> import axios from "axios";
> 
> export default function () {
>   let dogList = reactive({
>     urlList: [] as string[],
>     isLoading: false,
>   });
> 
>   async function getDog() {
>     dogList.isLoading = true; // 加载开始时设置为 true
>     try {
>       let result = await axios.get(
>         "https://dog.ceo/api/breed/pembroke/images/random"
>       );
>       dogList.urlList.push(result.data.message);
>     } catch (error) {
>       alert(error);
>     } finally {
>       dogList.isLoading = false; // 加载结束时设置为 false
>     }
>   }
> 
>   onMounted(() => {
>     getDog();
>   });
> 
>   return { dogList, getDog };
> }
> ```
>



## 指令与实际操作

### 类与样式绑定

#### 绑定 HTML class

##### 绑定对象

我们可以给 `:class` (`v-bind:class` 的缩写) 传递一个对象来动态切换 class。

> 你可以在对象中写多个字段来操作多个 class。此外，`:class` 指令也可以和一般的 `class` attribute 共存。举例来说，下面这样的状态：
>
> ```js
> const isActive = ref(true)
> const hasError = ref(false)
> ```
>
> 配合以下模板：
>
> ```vue
> <div
>   class="static"
>   :class="{ active: isActive, 'text-danger': hasError }"
> ></div>
> ```
>
> 上面的语法表示 `active` 是否存在取决于数据属性 `isActive` 的真假值。
>
> 渲染的结果会是：
>
> ```vue
> <div class="static active"></div>
> ```
>
> 当 `isActive` 或者 `hasError` 改变时，class 列表会随之更新。举例来说，如果 `hasError` 变为 `true`，class 列表也会变成 `"static active text-danger"`。
>
> 绑定的对象并不一定需要写成内联字面量的形式，也可以直接绑定一个对象：
>
> ```js
> const classObject = reactive({
>   active: true,
>   'text-danger': false
> })
> ```
>
> ```vue
> <div :class="classObject"></div>
> ```



##### 绑定数组

我们可以给 `:class` 绑定一个数组来渲染多个 CSS class。

> ```vue
> const activeClass = ref('active')
> const errorClass = ref('text-danger')
> ```
>
> ```vue
> <div :class="[activeClass, errorClass]"></div>
> ```
>
> 渲染的结果是：
>
> ```vue
> <div class="active text-danger"></div>
> ```
>
> 如果你也想在数组中有条件地渲染某个 class，你可以使用三元表达式：
>
> ```vue
> <div :class="[isActive ? activeClass : '', errorClass]"></div>
> ```
>
> `errorClass` 会一直存在，但 `activeClass` 只会在 `isActive` 为真时才存在。
>
> 然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象：
>
> ```vue
> <div :class="[{ [activeClass]: isActive }, errorClass]"></div>
> ```



##### 在组件上使用

对于只有一个根元素的组件，当使用 `class` attribute 时，这些 class 会被添加到根元素上并与该元素上已有的 class 合并。

> 举例来说，如果你声明了一个组件名叫 `MyComponent`，模板如下：
>
> ```html
> <!-- 子组件模板 -->
> <p class="foo bar">Hi!</p>
> ```
>
> 在使用时添加一些 class：
>
> ```html
> <!-- 在使用组件时 -->
> <MyComponent class="baz boo" />
> ```
>
> 渲染出的 HTML 为：
>
> ```html
> <p class="foo bar baz boo">Hi!</p>
> ```
>
> Class 的绑定也是同样的：
>
> ```html
> <MyComponent :class="{ active: isActive }" />
> ```
>
> 当 `isActive` 为真时，被渲染的 HTML 会是：
>
> ```html
> <p class="foo bar active">Hi!</p>
> ```
>
> 如果你的组件有多个根元素，你将需要指定哪个根元素来接收这个 class。你可以通过组件的 `$attrs` 属性来指定接收的元素：
>
> ```html
> <!-- MyComponent 模板使用 $attrs 时 -->
> <p :class="$attrs.class">Hi!</p>
> <span>This is a child component</span>
> ```
>
> ```html
> <MyComponent class="baz" />
> ```
>
> 这将被渲染为：
>
> ```html
> <p class="baz">Hi!</p>
> <span>This is a child component</span>
> ```



#### 绑定内联样式

##### 绑定对象

`:style` 支持绑定 JavaScript 对象值，对应的是 HTML 元素的 `style` 属性.

> ```js
> const activeColor = ref('red')
> const fontSize = ref(30)
> ```
>
> ```vue
> <div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
> ```
>
> 尽管推荐使用 camelCase，但 `:style` 也支持 kebab-cased 形式的 CSS 属性 key (对应其 CSS 中的实际名称)，例如：
>
> ```vue
> <div :style="{ 'font-size': fontSize + 'px' }"></div>
> ```
>
> 直接绑定一个样式对象通常是一个好主意，这样可以使模板更加简洁：
>
> ```js
> const styleObject = reactive({
>   color: 'red',
>   fontSize: '30px'
> })
> ```
>
> ```vue
> <div :style="styleObject"></div>
> ```
>
> 同样的，如果样式对象需要更复杂的逻辑，也可以使用返回样式对象的计算属性。

##### 绑定数组

我们还可以给 `:style` 绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一元素上：

```vue
<div :style="[baseStyles, overridingStyles]"></div>
```

##### 自动前缀

当你在 `:style` 中使用了需要[浏览器特殊前缀](https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix)的 CSS 属性时，Vue 会自动为他们加上相应的前缀。Vue 是在运行时检查该属性是否支持在当前浏览器中使用。如果浏览器不支持某个属性，那么将尝试加上各个浏览器特殊前缀，以找到哪一个是被支持的。

##### 样式多值

你可以对一个样式属性提供多个 (不同前缀的) 值

> 举例来说：
>
> ```vue
> <div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>
> ```
>
> 数组仅会渲染浏览器支持的最后一个值。在这个示例中，在支持不需要特别前缀的浏览器中都会渲染为 `display: flex`。



### 条件渲染

#### v-if

`v-if` 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回真值时才被渲染。

也可以使用 `v-else` 为 `v-if` 添加一个“else 区块”。

一个 `v-else` 元素必须跟在一个 `v-if` 或者 `v-else-if` 元素后面，否则它将不会被识别。

`v-else-if` 提供的是相应于 `v-if` 的“else if 区块”。它可以连续多次重复使用。

```vue
<script setup>
import { ref } from 'vue'
const num = ref(1)
</script>

<template>
	<button @click="num = (num + 1) % 4">toggle</button>
	<div v-if="num === 1">A</div>
	<div v-else-if="num === 2">B</div>
	<div v-else-if="num === 3">C</div>
	<div v-else>Not A/B/C</div>
</template>
```

##### \<template> 上的 v-if

因为 `v-if` 是一个指令，他必须依附于某个元素。但如果我们想要切换不止一个元素呢？在这种情况下我们可以在一个 `<template>` 元素上使用 `v-if`，这只是一个不可见的包装器元素，最后渲染的结果并不会包含这个 `<template>` 元素。

```vue
<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>
```

`v-else` 和 `v-else-if` 也可以在 `<template>` 上使用。



#### v-show

另一个可以用来按条件显示一个元素的指令是 `v-show`。

不同之处在于 `v-show` 会在 DOM 渲染中保留该元素；`v-show` 仅切换了该元素上名为 `display` 的 CSS 属性。

`v-show` 不支持在 `<template>` 元素上使用，也不能和 `v-else` 搭配使用。

```vue
<script setup>
import { ref } from 'vue'
const num = ref(1)
</script>

<template>
	<button @click="num = (num + 1) % 4">toggle</button>
	<div v-show="num === 1">A</div>
	<div v-show="num === 2">B</div>
	<div v-show="num === 3">C</div>
	<div v-show="num === 0">Not A/B/C</div>
</template>
```



#### 两者不同

`v-if` 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。

`v-if` 也是**惰性**的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。

相比之下，`v-show` 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS `display` 属性会被切换。

总的来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 `v-show` 较好；如果在运行时绑定条件很少改变，则 `v-if` 会更合适。



### 列表渲染

我们可以使用 `v-for` 指令基于一个数组来渲染一个列表。`v-for` 指令的值需要使用 `item in items` 形式的特殊语法，其中 `items` 是源数据的数组，而 `item` 是迭代项的**别名**。

```vue
<template>
  <ul>
    <li v-for="item in items">{{ item.name }}</li>
  </ul>
</template>

<script setup>
    items: [{ id: 1, name: 'Item 1' },{ id: 2, name: 'Item 2' },]
</script>
```

在 `v-for` 块中可以完整地访问父作用域内的属性和变量。`v-for` 也支持使用可选的第二个参数表示当前项的位置索引。

```vue
<template>
	<ul>
		<li v-for="(item, index) in items">{{ index }} - {{ item.name }}</li>
	</ul>
</template>

<script setup>
import { reactive } from 'vue'
let items = reactive([{ name: 'Item 1' }, { name: 'Item 2' }])
</script>
```

也可以使用 `of` 作为分隔符来替代 `in`，这更接近 JavaScript 的迭代器语法：

```vue
<div v-for="item of items"></div>
```

#### 使用解构

在 JavaScript 中，可以使用解构来提取对象的属性。同样地，在 `v-for` 中也可以使用解构语法：

```
javascript复制代码items.forEach(({ message }, index) => {
  console.log(message, index);
});
```

这个 `forEach` 回调函数解构了 `item` 对象，只提取 `message` 属性。

同样地，在 Vue 3 中，你可以在 `v-for` 中使用解构语法：

```vue
<template>
	<ul>
		<li v-for="({ message }, index) in items" :key="index">
			{{ message }} {{ index }}
		</li>
	</ul>
</template>

<script setup>
import { ref } from 'vue';
const items = ref([
	{ message: 'Hello' },
	{ message: 'World' }
]);
</script>
```

- `v-for="{ message } in items"` 解构 `item` 对象，只提取 `message` 属性。
- `v-for="({ message }, index) in items"` 解构 `item` 对象，并同时获取 `index` 索引。

这种用法使得代码更加简洁和易读，特别是在处理包含多个属性的对象时，通过解构可以直接使用所需的属性而无需显式地访问对象的每个属性。

#### 多层嵌套

对于多层嵌套的 `v-for`，作用域的工作方式和函数的作用域很类似。每个 `v-for` 作用域都可以访问到父级作用域：

```vue
<li v-for="item in items">
  <span v-for="childItem in item.children">
    {{ item.message }} {{ childItem }}
  </span>
</li>
```

#### v-for 与对象

可以使用 `v-for` 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 `Object.values()` 的返回值来决定。

可以通过提供第二个参数表示属性名 (例如 key)。

第三个参数表示位置索引。

```vue
<script setup>
import { reactive } from 'vue'

const myObject = reactive({
  title: 'How to do lists in Vue',
  author: 'Jane Doe',
  publishedAt: '2016-04-10'
})
</script>

<template>
  <ul>
    <li v-for="(value, key, index) in myObject">
      {{ index }}. {{ key }}: {{ value }}
    </li>
  </ul>
</template>
```

#### 使用范围值

`v-for` 可以直接接受一个整数值。在这种用例中，会将该模板基于 `1...n` 的取值范围重复多次。

```vue
<span v-for="n in 10">{{ n }}</span>
```

注意此处 `n` 的初值是从 `1` 开始而非 `0`。

#### \<template> 上的 v-for

与模板上的 `v-if` 类似，你也可以在 `<template>` 标签上使用 `v-for` 来渲染一个包含多个元素的块。例如：

```vue
<script setup>
import { reactive } from 'vue'

const myObject = reactive({
  title: 'How to do lists in Vue',
  author: 'Jane Doe',
  publishedAt: '2016-04-10'
})
</script>

<template>
  <ul>
    <template v-for="(value,key,index) in myObject">
      <li>{{ value }}</li>
      <li>{{ key }}</li>
      <li>{{ index }}</li>
    </template>
  </ul>
</template>
```

#### v-for 与 v-if

当它们同时存在于一个节点上时，`v-if` 比 `v-for` 的优先级更高。这意味着 `v-if` 的条件将无法访问到 `v-for` 作用域内定义的变量别名。

```vue
<!--
 这会抛出一个错误，因为属性 todo 此时
 没有在该实例上定义
-->
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo.name }}
</li>
```

在外先包装一层 `<template>` 再在其上使用 `v-for` 可以解决这个问题 (这也更加明显易读)：

```vue
<template v-for="todo in todos">
  <li v-if="!todo.isComplete">
    {{ todo.name }}
  </li>
</template>
```

#### 通过 key 管理状态

Vue 默认按照“就地更新”的策略来更新通过 `v-for` 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。

默认模式是高效的，但**只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况**。

为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 `key` attribute：

```vue
<div v-for="item in items" :key="item.id">
  <!-- 内容 -->
</div>
```

#### 组件上使用 v-for

我们可以直接在组件上使用 `v-for`，和在一般的元素上使用没有区别 (别忘记提供一个 `key`)：

```vue
<MyComponent v-for="item in items" :key="item.id" />
```

但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还需要传递 props：

```vue
<MyComponent
  v-for="(item, index) in items"
  :item="item"
  :index="index"
  :key="item.id"
/>
```

不自动将 `item` 注入组件的原因是，这会使组件与 `v-for` 的工作方式紧密耦合。明确其数据的来源可以使组件在其他情况下重用。

#### 数组变化侦测

Vue 能够侦听响应式数组的**变更方法**，并在它们被调用时触发相关的更新。包括：

- `push()`
- `pop()`
- `shift()`
- `unshift()`
- `splice()`
- `sort()`
- `reverse()`

变更方法，顾名思义，就是会对调用它们的原数组进行变更。

相对地，也有一些不可变 (immutable) 方法，例如 `filter()`，`concat()` 和 `slice()`，这些都不会更改原数组，而总是**返回一个新数组**。当遇到的是非变更方法时，我们需要将旧的数组替换为新的：

```js
let words = ref(['spray', 'elite', 'exuberant', 'destruction', 'present'])

words.value = words.value.filter(words.filter((word) => word.length > 6)
```

你可能认为这将导致 Vue 丢弃现有的 DOM 并重新渲染整个列表——幸运的是，情况并非如此。Vue 实现了一些巧妙的方法来最大化对 DOM 元素的重用，因此用另一个包含部分重叠对象的数组来做替换，仍会是一种非常高效的操作。

#### 展示过滤或排序后的结果

有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回已过滤或已排序数组的计算属性。

> 举例来说：
>
> ```js
> const numbers = ref([1, 2, 3, 4, 5])
> 
> const evenNumbers = computed(() => {
>   return numbers.value.filter((n) => n % 2 === 0)
> })
> ```
>
> ```vue
> <li v-for="n in evenNumbers">{{ n }}</li>
> ```
>
> 在计算属性不可行的情况下 (例如在多层嵌套的 `v-for` 循环中)，你可以使用以下方法：
>
> ```js
> const sets = ref([
>   [1, 2, 3, 4, 5],
>   [6, 7, 8, 9, 10]
> ])
> 
> function even(numbers) {
>   return numbers.filter((number) => number % 2 === 0)
> }
> ```
>
> ```vue
> <ul v-for="numbers in sets">
>   <li v-for="n in even(numbers)">{{ n }}</li>
> </ul>
> ```

在计算属性中使用 `reverse()` 和 `sort()` 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本。



### 事件处理

#### 监听事件

我们可以使用 `v-on` 指令 (简写为 `@`) 来监听 DOM 事件，并在事件触发时执行对应的 JavaScript。用法：`v-on:click="handler"` 或 `@click="handler"`。

事件处理器 (handler) 的值可以是：

1. **内联事件处理器**：事件被触发时执行的内联 JavaScript 语句 (与 `onclick` 类似)。
2. **方法事件处理器**：一个指向组件上定义的方法的属性名或是路径。

#### 内联事件处理器

内联事件处理器通常用于简单场景，例如：

```vue
<script setup>
import { ref } from 'vue'

const counter = ref(0)
</script>

<template>
	<button @click="counter++">Add 1</button>
	<p>The button above has been clicked {{ counter }} times.</p>
</template>
```

#### 方法事件处理器

随着事件处理器的逻辑变得愈发复杂，内联代码方式变得不够灵活。因此 `v-on` 也可以接受一个方法名或对某个方法的调用。

```vue
<script setup>
import { ref } from 'vue'

const name = ref('Vue.js')

function greet(event) {
  alert(`Hello ${name.value}!`)
  // `event` is the native DOM event
  if (event) {
    alert(event.target.tagName)
  }
}
</script>

<template>
	<button @click="greet">Greet</button>
</template>
```

#### 在内联事件处理器中访问事件参数

有时我们需要在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的 `$event` 变量，或者使用内联箭头函数：

```vue
<!-- 使用特殊的 $event 变量 -->
<button @click="warn('Form cannot be submitted yet.', $event)">
  Submit
</button>

<!-- 使用内联箭头函数 -->
<button @click="(event) => warn('Form cannot be submitted yet.', event)">
  Submit
</button>
```

```js
function warn(message, event) {
  // 这里可以访问原生事件
  if (event) {
    event.preventDefault()
  }
  alert(message)
}
```

#### 事件修饰符

在处理事件时调用 `event.preventDefault()` 或 `event.stopPropagation()` 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。

为解决这一问题，Vue 为 `v-on` 提供了**事件修饰符**。修饰符是用 `.` 表示的指令后缀，包含以下这些：

- `.stop` ：阻止事件传播。通常用于防止点击事件传递到父元素。
- `.prevent`：阻止默认行为。通常用于防止链接跳转或表单提交刷新页面。
- `.self`：仅当 event.target 是元素本身时才会触发事件处理器。忽略子元素触发的事件。
- `.capture`：使用事件捕获模式触发事件处理器。默认是事件冒泡模式。
- `.once`：事件处理器只触发一次。
- `.passive`：告诉浏览器你不想阻止默认行为，用于提高滚动性能。

```vue
<!-- 单击事件将停止传递 -->
<a @click.stop="doThis"></a>

<!-- 提交事件将不再重新加载页面 -->
<form @submit.prevent="onSubmit"></form>

<!-- 修饰语可以使用链式书写 -->
<a @click.stop.prevent="doThat"></a>

<!-- 也可以只有修饰符 -->
<form @submit.prevent></form>

<!-- 仅当 event.target 是元素本身时才会触发事件处理器 -->
<!-- 例如：事件处理器不来自子元素 -->
<div @click.self="doThat">...</div>
```

> 使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。因此使用 `@click.prevent.self` 会阻止**元素及其子元素的所有点击事件的默认行为**，而 `@click.self.prevent` 则只会阻止对元素本身的点击事件的默认行为。

`.capture`、`.once` 和 `.passive` 修饰符与 原生 `addEventListener` 事件 相对应：

```vue
<!-- 添加事件监听器时，使用 `capture` 捕获模式 -->
<!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 -->
<div @click.capture="doThis">...</div>

<!-- 点击事件最多被触发一次 -->
<a @click.once="doThis"></a>

<!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 -->
<!-- 以防其中包含 `event.preventDefault()` -->
<div @scroll.passive="onScroll">...</div>
```

`.passive` 修饰符一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能。

#### 按键修饰符

在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 `v-on` 或 `@` 监听按键事件时添加按键修饰符。

可以直接使用 [`KeyboardEvent.key`](https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent/key/Key_Values) 暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。

> ```vue
> <input @keyup.page-down="onPageDown" />
> ```
>
> 在上面的例子中，仅会在 `$event.key` 为 `'PageDown'` 时调用事件处理。

Vue 为一些常用的按键提供了别名：

- `.enter`
- `.tab`
- `.delete` (捕获“Delete”和“Backspace”两个按键)
- `.esc`
- `.space`
- `.up`
- `.down`
- `.left`
- `.right`

你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发：

- `.ctrl`
- `.alt`
- `.shift`
- `.meta`

鼠标按键修饰符：

- `.left`
- `.right`
- `.middle`

> 举例来说：
>
> ```vue
> <!-- Alt + Enter -->
> <input @keyup.alt.enter="clear" />
> 
> <!-- Ctrl + 点击 -->
> <div @click.ctrl="doSomething">Do something</div>
> ```

##### `.exact` 修饰符

`.exact` 修饰符允许精确控制触发事件所需的系统修饰符的组合。

```vue
<!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 -->
<button @click.ctrl="onClick">A</button>

<!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 -->
<button @click.ctrl.exact="onCtrlClick">A</button>

<!-- 仅当没有按下任何系统按键时触发 -->
<button @click.exact="onClick">A</button>
```



### 表单输入绑定

在前端处理表单时，我们常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。手动连接值绑定和更改事件监听器可能会很麻烦：

```vue
<input
  :value="text"
  @input="event => text = event.target.value">
```

`v-model` 指令帮我们简化了这一步骤：

```vue
<input v-model="text">
```

另外，`v-model` 还可以用于各种不同类型的输入，`<textarea>`、`<select>` 元素。它会根据所使用的元素自动使用对应的 DOM 属性和事件组合：

- 文本类型的 `<input>` 和 `<textarea>` 元素会绑定 `value` property 并侦听 `input` 事件；
- `<input type="checkbox">` 和 `<input type="radio">` 会绑定 `checked` property 并侦听 `change` 事件；
- `<select>` 会绑定 `value` property 并侦听 `change` 事件。

#### 基本用法

##### 文本输入( input / textarea )

```vue
<script setup>
import { ref } from 'vue'

const message = ref('')
</script>

<template>
	<span>
		多行显示(pre-line):
		<p style="white-space: pre-line;">{{ message }}</p>
	</span>
	<span>
		默认单行(normal):
		<p>{{ message }}</p>
	</span>
	<textarea v-model="message" placeholder="输入文字"></textarea>
</template>
```

##### 复选框( checkbox )

单一的复选框，绑定布尔类型值：

```vue
<input type="checkbox" id="checkbox" v-model="checked" />
<label for="checkbox">{{ checked }}</label>
```

也可以将多个复选框绑定到同一个数组或集合(set)的值：

```vue
<script setup>
import { ref } from 'vue'

const checkedNames = ref([])
</script>

<template>
  <div>Checked names: {{ checkedNames }}</div>

  <input type="checkbox" id="jack" value="Jack" v-model="checkedNames" />
  <label for="jack">Jack</label>
 
  <input type="checkbox" id="john" value="John" v-model="checkedNames" />
  <label for="john">John</label>
 
  <input type="checkbox" id="mike" value="Mike" v-model="checkedNames" />
  <label for="mike">Mike</label>
</template>
```

##### 单选按钮( radio )

```vue
<div>Picked: {{ picked }}</div>

<input type="radio" id="one" value="One" v-model="picked" />
<label for="one">One</label>

<input type="radio" id="two" value="Two" v-model="picked" />
<label for="two">Two</label>
```

##### 选择器( option )

单个选择器的示例如下：

```vue
<div>Selected: {{ selected }}</div>

<select v-model="selected">
  <option disabled value="">Please select one</option>
  <option>A</option>
  <option>B</option>
  <option>C</option>
</select>
```

多选 (值绑定到一个数组)：

```vue
<div>Selected: {{ selected }}</div>

<select v-model="selected" multiple>
  <option>A</option>
  <option>B</option>
  <option>C</option>
</select>
```

选择器的选项可以使用 `v-for` 动态渲染：

```js
const selected = ref('A')

const options = ref([
  { text: 'One', value: 'A' },
  { text: 'Two', value: 'B' },
  { text: 'Three', value: 'C' }
])
```

```vue
<select v-model="selected">
  <option v-for="option in options" :value="option.value">
    {{ option.text }}
  </option>
</select>

<div>Selected: {{ selected }}</div>
```

#### 值绑定

对于单选按钮，复选框和选择器选项，`v-model` 绑定的值通常是静态的字符串 (或者对复选框是布尔值)：

```vue
<!-- `picked` 在被选择时是字符串 "a" -->
<input type="radio" v-model="picked" value="a" />

<!-- `toggle` 只会为 true 或 false -->
<input type="checkbox" v-model="toggle" />

<!-- `selected` 在第一项被选中时为字符串 "abc" -->
<select v-model="selected">
  <option value="abc">ABC</option>
</select>
```

但有时我们可能希望将该值绑定到当前组件实例上的动态数据。这可以通过使用 `v-bind` 来实现。此外，使用 `v-bind` 还使我们可以将选项值绑定为非字符串的数据类型。

##### 复选框

```vue
<input
  type="checkbox"
  v-model="toggle"
  true-value="yes"
  false-value="no" />
```

`true-value` 和 `false-value` 是 Vue 特有的 attributes，仅支持和 `v-model` 配套使用。这里 `toggle` 属性的值会在选中时被设为 `'yes'`，取消选择时设为 `'no'`。你同样可以通过 `v-bind` 将其绑定为其他动态值：

```vue
<input
  type="checkbox"
  v-model="toggle"
  :true-value="dynamicTrueValue"
  :false-value="dynamicFalseValue" />
```

##### 单选按钮

```vue
<input type="radio" v-model="pick" :value="first" />
<input type="radio" v-model="pick" :value="second" />
```

`pick` 会在第一个按钮选中时被设为 `first`，在第二个按钮选中时被设为 `second`。

##### 选择器选项

```vue
<select v-model="selected">
  <!-- 内联对象字面量 -->
  <option :value="{ number: 123 }">123</option>
</select>
```

`v-model` 同样也支持非字符串类型的值绑定！在上面这个例子中，当某个选项被选中，`selected` 会被设为该对象字面量值 `{ number: 123 }`。

#### 修饰符

##### .lazy

默认情况下，`v-model` 会在每次 `input` 事件后更新数据 (IME 拼字阶段的状态例外)。你可以添加 `lazy` 修饰符来改为在每次 `change` 事件（用户离开输入框或按下回车键）后更新数据：

```vue
<!-- 在 "change" 事件后同步更新而不是 "input" -->
<input v-model.lazy="msg" />
```

##### .number

如果你想让用户输入自动转换为数字，你可以在 `v-model` 后添加 `.number` 修饰符来管理输入：

```vue
<input v-model.number="age" />
```

如果该值无法被 `parseFloat()` 处理，那么将返回原始值。

`number` 修饰符会在输入框有 `type="number"` 时自动启用。

##### .trim

如果你想要默认自动去除用户输入内容中两端的空格，你可以在 `v-model` 后添加 `.trim` 修饰符：

```vue
<input v-model.trim="msg" />
```
